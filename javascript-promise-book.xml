<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<!DOCTYPE article [<!ENTITY % db5ent PUBLIC "-//FOPUB//ENTITIES Entities for DocBook 5" "db5.ent"> %db5ent;]>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>JavaScript Promiseの本</title>
<date>2016-03-16</date>
<author>
<personname>
<firstname>azu</firstname>
</personname>
</author>
<authorinitials>azu</authorinitials>
</info>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/globe.png"/>
</imageobject>
<textobject><phrase>globe</phrase></textobject>
</inlinemediaobject> This book has been released in :</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Chinese</emphasis>: <link xl:href="http://liubin.github.io/promises-book/">JavaScript Promise迷你书（中文版）</link></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Korean</emphasis>: <link xl:href="http://www.hanbit.co.kr/ebook/look.html?isbn=9788968487293">한빛미디어 eBook JavaScript Promise（번역서）</link></simpara>
</listitem>
</itemizedlist>
<simpara><?asciidoc-hr?></simpara>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="introduction">
<title>はじめに</title>
<section xml:id="_書籍の目的">
<title>書籍の目的</title>
<simpara>この書籍はJavaScript標準仕様の<link linkend="es6-promises">ECMAScript 6 Promises</link>という仕様を中心にし、
JavaScriptにおけるPromiseについて学ぶことを目的とした書籍です。</simpara>
<simpara>この書籍を読むことで学べる事として次の3つを目標としています</simpara>
<itemizedlist>
<listitem>
<simpara>Promiseについて学び、パターンやテストを扱えるようになる事</simpara>
</listitem>
<listitem>
<simpara>Promiseの向き不向きについて学び、何でもPromiseで解決するべきではないと知る事</simpara>
</listitem>
<listitem>
<simpara>ES6 Promisesを元に基本をよく学び、より発展した形を自分で形成できるようになる事</simpara>
</listitem>
</itemizedlist>
<simpara>この書籍では、先程も述べたように<link linkend="es6-promises">ES6 Promises</link>、
つまりJavaScriptの標準仕様(ECMAScript)をベースとしたPromiseについて書かれています。</simpara>
<simpara>そのため、FirefoxやChromeなどモダンなブラウザでは、ライブラリを使うこと無く利用できる機能であり、
またES6 Promisesは元が<link linkend="promises-aplus">Promises/A+</link>というコミュニティベースの仕様であるため、多くの実装ライブラリがあります。</simpara>
<simpara>ブラウザネイティブの機能、またはライブラリを使うことで今すぐ利用できるPromiseについて基本的なAPIから学んでいきます。
その中でPromiseの得意/不得意を知り、Promiseを活用したJavaScriptを書けるようになることを目的としています。</simpara>
</section>
<section xml:id="_本書を読むにあたって">
<title>本書を読むにあたって</title>
<simpara>この書籍ではJavaScriptの基本的な機能について既に学習していることを前提にしています。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://www.oreilly.co.jp/books/9784873113913/">JavaScript: The Good Parts</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.oreilly.co.jp/books/9784873114880/">JavaScriptパターン</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.oreilly.co.jp/books/9784873115733/">JavaScript 第6版</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://gihyo.jp/book/2011/978-4-7741-4813-7?ard=1400715177">パーフェクトJavaScript</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://books.shoeisha.co.jp/book/b107881.html">Effective JavaScript</link></simpara>
</listitem>
</itemizedlist>
<simpara>のいずれかの書籍を読んだ事があれば十分読み解くことが出来る内容だと思います。</simpara>
<simpara>または、JavaScriptでウェブアプリケーションを書いたことがある、
Node.js でコマンドラインアプリやサーバサイドを書いたことがあれば、
どこかで書いたことがあるような内容が出てくるかもしれません。</simpara>
<simpara>一部セクションではNode.js環境での話となるため、Node.jsについて軽くでも知っておくとより理解がしやすいと思います。</simpara>
</section>
<section xml:id="_表記法">
<title>表記法</title>
<simpara>この書籍では短縮するために幾つかの表記を用いています。</simpara>
<itemizedlist>
<listitem>
<simpara>Promiseに関する用語は<link linkend="promise-glossary">用語集</link>を参照する。</simpara>
<itemizedlist>
<listitem>
<simpara>大体、初回に出てきた際にはリンクを貼っています。</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>インスタンスメソッドを instance#method という表記で示す。</simpara>
<itemizedlist>
<listitem>
<simpara>例えば、<literal>Promise#then</literal> という表記は、Promiseのインスタンスオブジェクトの <literal>then</literal> というメソッドを示しています。</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>オブジェクトメソッドを object.method という表記で示す。</simpara>
<itemizedlist>
<listitem>
<simpara>これはJavaScriptの意味そのままで、<literal>Promise.all</literal> なら静的メソッドの事を示しています。</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>この部分には文章についての補足が書かれています。</simpara>
</note>
</section>
<section xml:id="_本書のソースコード_ライセンス">
<title>本書のソースコード/ライセンス</title>
<simpara>この書籍に登場するサンプルのソースコード また その文章のソースコードは全てGitHubから取得することができます。</simpara>
<simpara>この書籍は <link xl:href="http://asciidoctor.org/">AsciiDoc</link> という形式で書かれています。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/azu/promises-book">azu/promises-book</link> <inlinemediaobject>
<imageobject>
<imagedata fileref="https://travis-ci.org/azu/promises-book.svg?branch=master"/>
</imageobject>
<textobject><phrase>Build Status</phrase></textobject>
</inlinemediaobject></simpara>
</listitem>
</itemizedlist>
<simpara>またリポジトリには書籍中に出てくるサンプルコードのテストも含まれています。</simpara>
<simpara>ソースコードのライセンスはMITライセンスで、文章はCC-BY-NCで利用することができます。</simpara>
</section>
<section xml:id="_意見や疑問点">
<title>意見や疑問点</title>
<simpara>意見や疑問点がある場合はGitHubに直接Issueとして立てる事が出来ます。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/azu/promises-book/issues?state=open">Issues · azu/promises-book</link></simpara>
</listitem>
</itemizedlist>
<simpara>また、この書籍についての <link xl:href="https://gitter.im/azu/promises-book">チャットページ</link> に書いていくのもいいでしょう。</simpara>
<simpara>Twitterでのハッシュタグは <inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/twitter.png"/>
</imageobject>
<textobject><phrase>twitter</phrase></textobject>
</inlinemediaobject> <link xl:href="https://twitter.com/search?q=%23Promise%E6%9C%AC">#Promise本</link>
なので、こちらを利用するのもいいでしょう。</simpara>
<simpara>この書籍は読める権利と同時に編集する権利があるため、
GitHubで <link xl:href="https://github.com/azu/promises-book/pulls">Pull Requests</link> も歓迎しています。</simpara>
</section>
</section>
<section xml:id="chapter1-what-is-promise">
<title>Chapter.1 - Promiseとは何か</title>
<simpara>この章では、JavaScriptにおけるPromiseについて簡単に紹介していきます。</simpara>
<section xml:id="what-is-promise">
<title>What Is Promise</title>
<simpara>まずPromiseとはそもそもどのようなものでしょうか?</simpara>
<simpara>Promiseは非同期処理を抽象化したオブジェクトとそれを操作する仕組みの事をいいます。
詳しくはこれから学んでいくとして、PromiseはJavaScriptで発見された概念ではありません。</simpara>
<simpara>最初に発見されたのは <link xl:href="http://erights.org/elib/distrib/pipeline.html">E言語</link>におけるもので、
並列/並行処理におけるプログラミング言語のデザインの一種です。</simpara>
<simpara>このデザインをJavaScriptに持ってきたものが、この書籍で学ぶJavaScript Promiseです。</simpara>
<simpara>一方、JavaScriptにおける非同期処理といえば、コールバックを利用する場合が多いと思います。</simpara>
<formalpara>
<title>コールバックを使った非同期処理の一例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">getAsync("fileA.txt", function(error, result){<co xml:id="CO1-1"/>
    if(error){// 取得失敗時の処理
        throw error;
    }
    // 取得成功の処理
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>コールバック関数の引数には(エラーオブジェクト, 結果)が入る</para>
</callout>
</calloutlist>
<simpara>Node.js等JavaScriptでのコールバック関数の第一引数には <literal>Error</literal> オブジェクトを渡すというルールを用いるケースがあります。</simpara>
<simpara>このようにコールバックでの非同期処理もルールが統一されていた場合、コールバック関数の書き方が明確になります。
しかし、これはあくまでコーディングルールであるため、異なる書き方をしても決して間違いではありません。</simpara>
<simpara>Promiseでは、このような非同期に対するオブジェクトとルールを仕様化して、
統一的なインターフェースで書くようになっており、それ以外の書き方は出来ないようになっています。</simpara>
<formalpara>
<title>Promiseを使った非同期処理の一例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var promise = getAsyncPromise("fileA.txt"); <co xml:id="CO2-1"/>
promise.then(function(result){
    // 取得成功の処理
}).catch(function(error){
    // 取得失敗時の処理
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO2-1">
<para>promiseオブジェクトを返す</para>
</callout>
</calloutlist>
<simpara>非同期処理を抽象化したpromiseオブジェクトというものを用意し、
そのpromiseオブジェクトに対して成功時の処理と失敗時の処理の関数を登録するようにして使います。</simpara>
<simpara>コールバック関数と比べると何が違うのかを簡単に見ると、
非同期処理の書き方がpromiseオブジェクトのインターフェースに沿った書き方に限定されます。</simpara>
<simpara>つまり、promiseオブジェクトに用意されてるメソッド(ここでは <literal>then</literal> や <literal>catch</literal>)以外は使えないため、
コールバックのように引数に何を入れるかが自由に決められるわけではなく、一定のやり方に統一されます。</simpara>
<simpara>この、Promiseという統一されたインターフェースがあることで、
そのインターフェースにおける様々な非同期処理のパターンを形成することが出来ます。</simpara>
<simpara>つまり、複雑な非同期処理等を上手くパターン化できるというのがPromiseの役割であり、
Promiseを使う理由の一つであるといえるでしょう。</simpara>
<simpara>それでは、実際にJavaScriptでのPromiseについて学んでいきましょう。</simpara>
</section>
<section xml:id="promises-overview">
<title>Promise Overview</title>
<simpara><link linkend="es6-promises">ES6 Promises</link>の仕様で定義されているAPIはそこまで多くはありません。</simpara>
<simpara>大きく分けて以下の3種類になります。</simpara>
<simpara><emphasis role="strong">Constructor</emphasis></simpara>
<simpara>Promiseは <literal>XMLHttpRequest</literal> のように、コンストラクタ関数である <literal>Promise</literal> からインスタンスとなる
promiseオブジェクトを作成して利用します。</simpara>
<simpara>promiseオブジェクトを作成するには、<literal>Promise</literal> コンストラクタを <literal>new</literal> でインスタンス化します。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var promise = new Promise(function(resolve, reject) {
    // 非同期の処理
    // 処理が終わったら、resolve または rejectを呼ぶ
});</programlisting>
<simpara><emphasis role="strong">Instance Method</emphasis></simpara>
<simpara>newによって生成されたpromiseオブジェクトにはpromiseの値を <emphasis role="strong">resolve</emphasis>(成功) / <emphasis role="strong">reject</emphasis>(失敗) した時に呼ばれる
コールバック関数を登録するために <literal>promise.then()</literal> というインスタンスメソッドがあります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">promise.then(onFulfilled, onRejected)</programlisting>
<variablelist>
<varlistentry>
<term>resolve(成功)した時</term>
<listitem>
<simpara><literal>onFulfilled</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>reject(失敗)した時</term>
<listitem>
<simpara><literal>onRejected</literal>  が呼ばれる</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><literal>onFulfilled</literal>、<literal>onRejected</literal> どちらもオプショナルな引数となっています。</simpara>
<simpara><literal>promise.then</literal> では成功時と失敗時の処理を同時に登録することが出来ます。
また、エラー処理だけを書きたい場合には <literal>promise.then(undefined, onRejected)</literal> と同じ意味である
<literal>promise.catch(onRejected)</literal> を使うことが出来ます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">promise.catch(onRejected)</programlisting>
<simpara><emphasis role="strong">Static Method</emphasis></simpara>
<simpara><literal>Promise</literal> というグローバルオブジェクトには幾つかの静的なメソッドが存在します。</simpara>
<simpara><literal>Promise.all()</literal> や <literal>Promise.resolve()</literal> などが該当し、Promiseを扱う上での補助メソッドが中心となっています。</simpara>
<section xml:id="_promise_workflow">
<title>Promise workflow</title>
<simpara>以下のようなサンプルコードを見てみましょう。</simpara>
<formalpara xml:id="promise-workflow.js" role="executable">
<title>promise-workflow.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function asyncFunction() {
    <co xml:id="CO3-1"/>
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve('Async Hello world');
        }, 16);
    });
}
<co xml:id="CO3-2"/>
asyncFunction().then(function (value) {
    console.log(value);    // =&gt; 'Async Hello world'
}).catch(function (error) {
    console.log(error);
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-1">
<para>Promiseコンストラクタを <literal>new</literal> して、promiseオブジェクトを返します</para>
</callout>
<callout arearefs="CO3-2">
<para>&lt;1&gt;のpromiseオブジェクトに対して <literal>.then</literal> で値が返ってきた時のコールバックを設定します</para>
</callout>
</calloutlist>
<simpara><literal>asyncFunction</literal> という関数 は promiseオブジェクトを返していて、
そのpromiseオブジェクトに対して <literal>then</literal> でresolveした時のコールバックを、
<literal>catch</literal> でエラーとなった場合のコールバックを設定しています。</simpara>
<simpara>このpromiseオブジェクトはsetTimeoutで16ms後にresolveされるので、
そのタイミングで <literal>then</literal> のコールバックが呼ばれ <literal>'Async Hello world'</literal> と出力されます。</simpara>
<simpara>この場合 <literal>catch</literal> のコールバックは呼ばれる事はないですが、
<literal>setTimeout</literal> が存在しない環境などでは、例外が発生し <literal>catch</literal> で登録したコールバック関数が呼ばれると思います。</simpara>
<simpara>もちろん、<literal>promise.then(onFulfilled, onRejected)</literal> というように、
<literal>catch</literal> を使わずに <literal>then</literal> を使い、以下のように2つのコールバック関数を設定することでもほぼ同様の動作になります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">asyncFunction().then(function (value) {
    console.log(value);
}, function (error) {
    console.log(error);
});</programlisting>
</section>
<section xml:id="promise-states">
<title>Promiseの状態</title>
<simpara>Promiseの処理の流れが少しわかった所で、少しPromiseの状態について整理したいと思います。</simpara>
<simpara><literal>new Promise</literal> でインスタンス化したpromiseオブジェクトには以下の3つの状態が存在します。</simpara>
<variablelist>
<varlistentry>
<term>Fulfilled</term>
<listitem>
<simpara>resolve(成功)した時。この時 <literal>onFulfilled</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Rejected</term>
<listitem>
<simpara>reject(失敗)した時。この時 <literal>onRejected</literal>  が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Pending</term>
<listitem>
<simpara>FulfilledまたはRejectedではない時。つまりpromiseオブジェクトが作成された初期状態等が該当する</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>これらの状態は<link linkend="es6-promises">ES6 Promises</link>の仕様で定められている名前です。
この状態をプログラムで直接触る方法は用意されていないため、書く際には余り気にしなくても問題ないですが、
Promiseについて理解するのに役に立ちます。</simpara>
<simpara>この書籍では、<emphasis>Pending</emphasis>、<emphasis>Fulfilled</emphasis> 、<emphasis>Rejected</emphasis> の状態を用いて解説していきます。</simpara>
<figure>
<title>promise states</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch1_WhatsPromises/img/promise-states.png"/>
</imageobject>
<textobject><phrase>promise-states</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara><link linkend="es6-promises">ES6 Promisesの仕様</link> では <literal>[[PromiseStatus]]</literal> という内部定義によって状態が定められています。
<literal>[[PromiseStatus]]</literal> にアクセスするユーザーAPIは用意されていないため、基本的には知る方法はありません。</simpara>
</note>
<simpara>3つの状態を見たところで、既にこの章で全ての状態が出てきていることが分かります。</simpara>
<simpara>promiseオブジェクトの状態は、一度<emphasis>Pending</emphasis>から<emphasis>Fulfilled</emphasis>や<emphasis>Rejected</emphasis>になると、
そのpromiseオブジェクトの状態はそれ以降変化することはなくなります。</simpara>
<simpara>つまり、PromiseはEvent等とは違い、<literal>.then</literal> で登録した関数が呼ばれるのは1回限りという事が明確になっています。</simpara>
<simpara>また、<emphasis>Fulfilled</emphasis>と<emphasis>Rejected</emphasis>のどちらかの状態であることを<emphasis role="strong">Settled</emphasis>(不変の)と表現することがあります。</simpara>
<variablelist>
<varlistentry>
<term>Settled</term>
<listitem>
<simpara>resolve(成功) または reject(失敗) した時。</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Pending</emphasis>と<emphasis>Settled</emphasis>が対となる関係であると考えると、Promiseの状態の種類/遷移がシンプルであることがわかると思います。</simpara>
<simpara>このpromiseオブジェクトの状態が変化した時に、一度だけ呼ばれる関数を登録するのが <literal>.then</literal> といったメソッドとなるわけです。</simpara>
<note>
<simpara><link xl:href="https://speakerdeck.com/kerrick/javascript-promises-thinking-sync-in-an-async-world">JavaScript Promises - Thinking Sync in an Async World // Speaker Deck</link>
というスライドではPromiseの状態遷移について分かりやすく書かれています。</simpara>
</note>
</section>
</section>
<section xml:id="how-to-write-promise">
<title>Promiseの書き方</title>
<simpara>Promiseの基本的な書き方について解説します。</simpara>
<section xml:id="_promiseオブジェクトの作成">
<title>promiseオブジェクトの作成</title>
<simpara>promiseオブジェクトを作る流れは以下のようになっています。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>new Promise(fn)</literal> の返り値がpromiseオブジェクト</simpara>
</listitem>
<listitem>
<simpara><literal>fn</literal> には非同期等の何らかの処理を書く</simpara>
<itemizedlist>
<listitem>
<simpara>処理結果が正常なら、<literal>resolve(結果の値)</literal> を呼ぶ</simpara>
</listitem>
<listitem>
<simpara>処理結果がエラーなら、<literal>reject(Errorオブジェクト)</literal> を呼ぶ</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>この流れに沿っているものを実際に書いてみましょう。</simpara>
<simpara>非同期処理であるXMLHttpRequest(XHR)を使いデータを取得するものをPromiseで書いていきます。</simpara>
<section xml:id="_xhrのpromiseオブジェクトを作る">
<title>XHRのpromiseオブジェクトを作る</title>
<simpara>まずは、XHRをPromiseを使って包んだような <literal>getURL</literal> という関数を作ります。</simpara>
<formalpara xml:id="xhr-promise.js" role="executable">
<title>xhr-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function getURL(URL) {
    return new Promise(function (resolve, reject) {
        var req = new XMLHttpRequest();
        req.open('GET', URL, true);
        req.onload = function () {
            if (req.status === 200) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = function () {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
// 実行例
var URL = "http://httpbin.org/get";
getURL(URL).then(function onFulfilled(value){
    console.log(value);
}).catch(function onRejected(error){
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>この <literal>getURL</literal> では、
XHRでの取得結果のステータスコードが200の場合のみ <literal>resolve</literal> - つまり取得に成功、
それ以外はエラーであるとして <literal>reject</literal> しています。</simpara>
<simpara><literal>resolve(req.responseText)</literal> ではレスポンスの内容を引数に入れています。
resolveの引数に入れる値には特に決まりはありませんが、コールバックと同様に次の処理へ渡したい値を入れるといいでしょう。
(この値は <literal>then</literal> メソッドで受け取ることが出来ます)</simpara>
<simpara>Node.jsをやっている人は、コールバックを書く時に <literal>callback(error, response)</literal> と第一引数にエラーオブジェクトを
入れることがよくあると思いますが、Promiseでは役割がresolve/rejectで分担されているので、
resolveにはresponseの値のみをいれるだけで問題ありません。</simpara>
<simpara>次に、<literal>reject</literal> の方を見て行きましょう。</simpara>
<simpara>XHRで <literal>onerror</literal> のイベントが呼ばれた場合はもちろんエラーなので <literal>reject</literal> を呼びます。
ここで <literal>reject</literal> に渡している値に注目してみてください。</simpara>
<simpara>エラーの場合は <literal>reject(new Error(req.statusText));</literal> というように、Errorオブジェクトを作成して渡している事がわかると思います。
<literal>reject</literal> に渡す値に制限はありませんが、一般的にErrorオブジェクト(またはErrorオブジェクトを継承したもの)を渡すことになっています。</simpara>
<simpara><literal>reject</literal> に渡す値は、rejectする理由を書いたErrorオブジェクトとなっています。
今回は、ステータスコードが200以外であるならrejectするとしていたため、<literal>reject</literal> にはstatusTextを入れています。
(この値は <literal>then</literal> メソッドの第二引数 or <literal>catch</literal> メソッドで受け取ることが出来ます)</simpara>
</section>
</section>
<section xml:id="_promiseオブジェクトに処理を書く">
<title>promiseオブジェクトに処理を書く</title>
<simpara>先ほどの作成したpromiseオブジェクトを返す関数を実際に使ってみましょう</simpara>
<programlisting language="javascript" linenumbering="unnumbered">getURL("http://example.com/"); // =&gt; promiseオブジェクトが返ってくる</programlisting>
<simpara><link linkend="promises-overview">Promises Overview</link> でも簡単に紹介したようにpromiseオブジェクトは幾つかインスタンスメソッドを持っており、
これを使いpromiseオブジェクトの状態に応じて一度だけ呼ばれるコールバックとなる関数を登録します。</simpara>
<simpara>promiseオブジェクトに登録する処理は以下の2種類が主となります</simpara>
<itemizedlist>
<listitem>
<simpara>promiseオブジェクトが <emphasis role="strong">resolve</emphasis> された時の処理(onFulfilled)</simpara>
</listitem>
<listitem>
<simpara>promiseオブジェクトが <emphasis role="strong">reject</emphasis> された時の処理(onRejected)</simpara>
</listitem>
</itemizedlist>
<figure xml:id="promise-value-flow">
<title>promise value flow</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch1_WhatsPromises/img/promise-onFulfilled_onRejected.png"/>
</imageobject>
<textobject><phrase>promise-resolve-flow</phrase></textobject>
</mediaobject>
</figure>
<simpara>まずは、<literal>getURL</literal> で通信が成功して値が取得出来た場合の処理を書いてみましょう。</simpara>
<simpara>この場合の <emphasis>通信が成功した</emphasis> というのは、
resolveされたことにより <emphasis>promiseオブジェクトがFulFilledの状態になった</emphasis> 時という事ですね。</simpara>
<simpara><emphasis role="strong">resolve</emphasis>された時の処理は、 <link linkend="promise.then"><literal>.then</literal></link> メソッドに呼びたい関数を渡すことで行えます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var URL = "http://httpbin.org/get";
getURL(URL).then(function onFulfilled(value){ <co xml:id="CO4-1"/>
    console.log(value);
});</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>分かりやすくするため関数に <literal>onFulfilled</literal> という名前を付けています</para>
</callout>
</calloutlist>
<simpara><link linkend="xhr-promise.js">getURL関数</link> 内で <literal>resolve(req.responseText);</literal> によってpromiseオブジェクトが解決されると、
値と共に <literal>onFulfilled</literal> 関数が呼ばれます。</simpara>
<simpara>このままでは通信エラーが起きた場合などに何も処理がされないため、
今度は、<literal>getURL</literal> で何らかの問題があってエラーが起きた場合の処理を書いてみましょう。</simpara>
<simpara>この場合の <emphasis>エラーが起きた</emphasis> というのは、
rejectされたことより <emphasis>promiseオブジェクトがRejectedの状態になった</emphasis> 時という事ですね。</simpara>
<simpara><emphasis role="strong">reject</emphasis>された時の処理は、<link linkend="promise.then"><literal>.then</literal> の第二引数</link> または <link linkend="promise.catch"><literal>.catch</literal></link> メソッドに呼びたい関数を渡す事で行えます。</simpara>
<simpara>先ほどのソースにrejectされた場合の処理を追加してみましょう。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var URL = "http://httpbin.org/status/500"; <co xml:id="CO5-1"/>
getURL(URL).then(function onFulfilled(value){
    console.log(value);
}).catch(function onRejected(error){ <co xml:id="CO5-2"/>
    console.error(error);
});</programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>サーバはステータスコード500のレスポンスを返す</para>
</callout>
<callout arearefs="CO5-2">
<para>分かりやすくするため関数 <literal>onRejected</literal> という名前を付けています</para>
</callout>
</calloutlist>
<simpara><literal>getURL</literal> の処理中に何らかの理由で例外が起きた場合、または明示的にrejectされた場合に、
その理由(Errorオブジェクト)と共に <link linkend="promise.catch"><literal>.catch</literal></link> の処理が呼ばれます。</simpara>
<simpara><link linkend="promise.catch"><literal>.catch</literal></link>は <literal>promise.then(undefined, onRejected)</literal> のエイリアスであるため、
同様の処理は以下のように書くことも出来ます。</simpara>
<programlisting xml:id="catch-as-alias" language="javascript" linenumbering="unnumbered">getURL(URL).then(onFulfilled, onRejected);<co xml:id="CO6-1"/></programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>onFulfilled, onRejected それぞれは先ほどと同じ関数</para>
</callout>
</calloutlist>
<simpara>基本的には、<link linkend="promise.catch"><literal>.catch</literal></link>を使いresolveとrejectそれぞれを別々に処理した方がよいと考えられますが、
両者の違いについては <link linkend="then-or-catch">thenとcatchの違い</link> で紹介します。</simpara>
<section xml:id="_まとめ">
<title>まとめ</title>
<simpara>この章では以下のことについて簡単に紹介しました。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>new Promise</literal> を使ったpromiseオブジェクトの作成</simpara>
</listitem>
<listitem>
<simpara><link linkend="promise.then"><literal>.then</literal></link> や <link linkend="promise.catch"><literal>.catch</literal></link> を使ったpromiseオブジェクトの処理</simpara>
</listitem>
</itemizedlist>
<simpara>Promiseの基本的な書き方について学びました。
他の多くの処理はこれを発展させたり、用意された静的メソッドを利用したものになります。</simpara>
<simpara>ここでは、同様の事はコールバック関数を渡す形でも出来るのに対してPromiseで書くメリットについては触れていませんでした。
次の章では、Promiseのメリットであるエラーハンドリングの仕組みをコールバックベースの実装と比較しながら見て行きたいと思います。</simpara>
</section>
</section>
</section>
</section>
<section xml:id="chapter2-how-to-write-promise">
<title>Chapter.2 - Promiseの書き方</title>
<simpara>この章では、Promiseのメソッドの使い方、エラーハンドリングについて学びます。</simpara>
<section xml:id="ch2-promise-resolve">
<title>Promise.resolve</title>
<simpara>一般に <literal>new Promise()</literal> を使う事でpromiseオブジェクトを生成しますが、
それ以外にもpromiseオブジェクトを生成する方法があります。</simpara>
<simpara>ここでは、<link linkend="Promise.resolve"><literal>Promise.resolve</literal></link> と <link linkend="Promise.reject"><literal>Promise.reject</literal></link> について学びたいと思います。</simpara>
<section xml:id="_new_promiseのショートカット">
<title>new Promiseのショートカット</title>
<simpara><link linkend="Promise.resolve"><literal>Promise.resolve(value)</literal></link> という静的メソッドは、
<literal>new Promise()</literal> のショートカットとなるメソッドです。</simpara>
<simpara>例えば、 <literal>Promise.resolve(42);</literal> というのは下記のコードのシンタックスシュガーです。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">new Promise(function(resolve){
    resolve(42);
});</programlisting>
<simpara>結果的にすぐに <literal>resolve(42);</literal> と解決されて、次のthenの <literal>onFulfilled</literal> に設定された関数に <literal>42</literal> という値を渡します。</simpara>
<simpara><literal>Promise.resolve(value);</literal> で返ってくる値も同様にpromiseオブジェクトなので、
以下のように続けて <literal>.then</literal> を使った処理を書くことが出来ます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">Promise.resolve(42).then(function(value){
    console.log(value);
});</programlisting>
<simpara><link linkend="Promise.resolve">Promise.resolve</link>は <literal>new Promise()</literal> のショートカットとして、
promiseオブジェクトの初期化時やテストコードを書く際にも活用できます。</simpara>
</section>
<section xml:id="_thenable">
<title>Thenable</title>
<simpara>もう一つ <literal>Promise.resolve</literal> の大きな特徴として、<link linkend="Thenable">thenable</link>なオブジェクトをpromiseオブジェクトに変換するという機能があります。</simpara>
<simpara><link linkend="es6-promises">ES6 Promises</link>には<link linkend="Thenable">Thenable</link>という概念があり、簡単にいえばpromiseっぽいオブジェクトの事を言います。</simpara>
<simpara><literal>.length</literal> を持っているが配列ではないものをArray likeというのと同じで、
thenableの場合は <literal>.then</literal> というメソッドを持ってるオブジェクトを言います。</simpara>
<simpara>thenableなオブジェクトが持つ <literal>then</literal> は、Promiseの持つ <literal>then</literal> と同じような挙動を期待していて、
thenableなオブジェクトが持つ元々の <literal>then</literal> を上手く利用できるようにしpromiseオブジェクトに変換するという仕組みです。</simpara>
<simpara>どういうものがthenableなのかというと、分かりやすい例では
<link xl:href="https://api.jquery.com/jQuery.ajax/">jQuery.ajax()</link>の返り値もthenableです。</simpara>
<simpara><literal>jQuery.ajax()</literal> の返り値は <link xl:href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</link> というもので、
このオブジェクトは <literal>.then</literal> というメソッドを持っているためです。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">$.ajax('/json/comment.json');// =&gt; `.then` を持つオブジェクト</programlisting>
<simpara>このthenableなオブジェクトを <literal>Promise.resolve</literal> ではpromiseオブジェクトにすることが出来ます。</simpara>
<simpara>promiseオブジェクトにすることができれば、<literal>then</literal> や <literal>catch</literal> といった、
<link linkend="es6-promises">ES6 Promises</link>が持つ機能をそのまま利用することが出来るようになります。</simpara>
<formalpara>
<title>thenableをpromiseオブジェクトにする</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var promise = Promise.resolve($.ajax('/json/comment.json'));// =&gt; promiseオブジェクト
promise.then(function(value){
   console.log(value);
});</programlisting>
</para>
</formalpara>
<warning>
<title>jQueryとthenable</title>
<simpara><link xl:href="https://api.jquery.com/jQuery.ajax/">jQuery.ajax()</link>の返り値も <literal>.then</literal> というメソッドを持った <link xl:href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</link>で、
このオブジェクトは <link xl:href="http://api.jquery.com/category/deferred-object/">Deferred Object</link> のメソッドやプロパティ等を継承しています。</simpara>
<simpara>しかし、このDeferred Objectは<link linkend="promises-aplus">Promises/A+</link>や<link linkend="es6-promises">ES6 Promises</link>に準拠したものではないため、
変換できたように見えて一部欠損する情報がでてしまうという問題があります。</simpara>
<simpara>この問題はjQueryの <link xl:href="http://api.jquery.com/category/deferred-object/">Deferred Object</link> の <literal>then</literal> の挙動が違うために発生します。</simpara>
<simpara>そのため、<literal>.then</literal> というメソッドを持っていた場合でも、必ずES6 Promisesとして使えるとは限らない事は知っておくべきでしょう。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://www.html5rocks.com/ja/tutorials/es6/promises/#toc-lib-compatibility">JavaScript Promises: There and back again - HTML5 Rocks</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">You&#39;re Missing the Point of Promises</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://twitter.com/hirano_y_aa/status/398851806383452160">https://twitter.com/hirano_y_aa/status/398851806383452160</link></simpara>
</listitem>
</itemizedlist>
</warning>
<simpara><literal>Promise.resolve</literal> は共通の挙動である <literal>then</literal> だけを利用して、
様々なライブラリ間でのpromiseオブジェクトを相互に変換して使える仕組みを持っている事になります。</simpara>
<simpara>このthenableを変換する機能は、以前は <literal>Promise.cast</literal> という名前であった事からもその挙動が想像できるかもしれません。</simpara>
<simpara>ThenableについてはPromiseを使ったライブラリを書くとき等には知っておくべきですが、
通常の利用だとそこまで使う機会がないものかもしれません。</simpara>
<note>
<simpara>ThenableとPromise.resolveの具体的な例を交えたものは
第4章の<link linkend="resolve-thenable">Promise.resolveとThenable</link>にて詳しく解説しています。</simpara>
</note>
<simpara><literal>Promise.resolve</literal> を簡単にまとめると、「渡した値でFulfilledされるpromiseオブジェクトを返すメソッド」と考えるのがいいでしょう。</simpara>
<simpara>また、Promiseの多くの処理は内部的に <literal>Promise.resolve</literal> のアルゴリズムを使って値をpromiseオブジェクトに変換しています。</simpara>
</section>
</section>
<section xml:id="ch2-promise-reject">
<title>Promise.reject</title>
<simpara><link linkend="Promise.reject"><literal>Promise.reject(error)</literal></link>は
<link linkend="Promise.resolve"><literal>Promise.resolve(value)</literal></link> と同じ静的メソッドで <literal>new Promise()</literal> のショートカットとなるメソッドです。</simpara>
<simpara>例えば、 <literal>Promise.reject(new Error("エラー"))</literal> というのは下記のコードのシンタックスシュガーです。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">new Promise(function(resolve,reject){
    reject(new Error("エラー"));
});</programlisting>
<simpara>返り値のpromiseオブジェクトに対して、thenの <literal>onRejected</literal> に設定された関数にエラーオブジェクトが渡ります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">Promise.reject(new Error("BOOM!")).catch(function(error){
    console.error(error);
});</programlisting>
<simpara><link linkend="Promise.resolve"><literal>Promise.resolve(value)</literal></link> との違いは resolveではなくrejectが呼ばれるという点で、
テストコードやデバッグ、一貫性を保つために利用する機会などがあるかもしれません。</simpara>
</section>
<section xml:id="promise-is-always-async">
<title>コラム: Promiseは常に非同期?</title>
<simpara><link linkend="Promise.resolve"><literal>Promise.resolve(value)</literal></link> 等を使った場合、
promiseオブジェクトがすぐにresolveされるので、<literal>.then</literal> に登録した関数も同期的に処理が行われるように錯覚してしまいます。</simpara>
<simpara>しかし、実際には <literal>.then</literal> で登録した関数が呼ばれるのは、非同期となります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">var promise = new Promise(function (resolve){
    console.log("inner promise"); // 1
    resolve(42);
});
promise.then(function(value){
    console.log(value); // 3
});
console.log("outer promise"); // 2</programlisting>
<simpara>上記のコードを実行すると以下の順に呼ばれていることが分かります。</simpara>
<screen>inner promise // 1
outer promise // 2
42            // 3</screen>
<simpara>JavaScriptは上から実行されていくため、まず最初に <literal>&lt;1&gt;</literal> が実行されますね。
そして次に <literal>resolve(42);</literal> が実行され、この <literal>promise</literal> オブジェクトはこの時点で <literal>42</literal> という値にFulFilledされます。</simpara>
<simpara>次に、<literal>promise.then</literal> で <literal>&lt;3&gt;</literal> のコールバック関数を登録しますが、ここがこのコラムの焦点です。</simpara>
<simpara><literal>promise.then</literal> を行う時点でpromiseオブジェクトの状態が決まっているため、
プログラム的には同期的にコールバック関数に <literal>42</literal> を渡して呼び出す事はできますね。</simpara>
<simpara>しかし、Promiseでは <literal>promise.then</literal> で登録する段階でpromiseの状態が決まっていても、
そこで登録したコールバック関数は非同期で呼び出される仕様になっています。</simpara>
<simpara>そのため、<literal>&lt;2&gt;</literal> が先に呼び出されて、最後に <literal>&lt;3&gt;</literal> のコールバック関数が呼ばれています。</simpara>
<simpara>何故、同期的に呼び出せるのにわざわざ非同期的に呼び出しているでしょうか?</simpara>
<section xml:id="_同期と非同期の混在の問題">
<title>同期と非同期の混在の問題</title>
<simpara>これはPromise以外でも適用できるため、もう少し一般的な問題として考えてみましょう。</simpara>
<simpara>この問題はコールバック関数を受け取る関数が、
状況によって同期処理になるのか非同期処理になるのかが変わってしまう問題と同じです。</simpara>
<simpara>次のような、コールバック関数を受け取り処理する <literal>onReady(fn)</literal> を見てみましょう。</simpara>
<formalpara xml:id="mixed-onready.js" role="executable">
<title>mixed-onready.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function onReady(fn) {
    var readyState = document.readyState;
    if (readyState === 'interactive' || readyState === 'complete') {
        fn();
    } else {
        window.addEventListener('DOMContentLoaded', fn);
    }
}
onReady(function () {
    console.log('DOM fully loaded and parsed');
});
console.log('==Starting==');</programlisting>
</para>
</formalpara>
<simpara><xref linkend="mixed-onready.js"/>ではDOMが読み込み済みかどうかで、
コールバック関数が同期的か非同期的に呼び出されるのかが異なっています。</simpara>
<variablelist>
<varlistentry>
<term>onReadyを呼ぶ前にDOMの読み込みが完了している</term>
<listitem>
<simpara>同期的にコールバック関数が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>onReadyを呼ぶ前にDOMの読み込みが完了していない</term>
<listitem>
<simpara><literal>DOMContentLoaded</literal> のイベントハンドラとしてコールバック関数を設定する</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>そのため、このコードは配置する場所によって、
コンソールに出てくるメッセージの順番が変わってしまいます。</simpara>
<simpara>この問題の対処法として常に非同期で呼び出すように統一することです。</simpara>
<formalpara xml:id="async-onready.js" role="executable">
<title>async-onready.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function onReady(fn) {
    var readyState = document.readyState;
    if (readyState === 'interactive' || readyState === 'complete') {
        setTimeout(fn, 0);
    } else {
        window.addEventListener('DOMContentLoaded', fn);
    }
}
onReady(function () {
    console.log('DOM fully loaded and parsed');
});
console.log('==Starting==');</programlisting>
</para>
</formalpara>
<simpara>この問題については、 <link xl:href="http://effectivejs.com/">Effective JavaScript</link> の
<emphasis role="strong">項目67 非同期コールバックを同期的に呼び出してはいけない</emphasis> で紹介されています。</simpara>
<blockquote>
<attribution>
David Herman
<citetitle>Effective JavaScript</citetitle>
</attribution>
<itemizedlist>
<listitem>
<simpara>非同期コールバックは（たとえデータが即座に利用できても）決して同期的に使ってはならない。</simpara>
</listitem>
<listitem>
<simpara>非同期コールバックを同期的に呼び出すと、処理の期待されたシーケンスが乱され、
コードの実行順序に予期しない変動が生じるかもしれない。</simpara>
</listitem>
<listitem>
<simpara>非同期コールバックを同期的に呼び出すと、スタックオーバーフローや例外処理の間違いが発生するかもしれない。</simpara>
</listitem>
<listitem>
<simpara>非同期コールバックを次回に実行されるようスケジューリングするには、<literal>setTimeout</literal> のような非同期APIを使う。</simpara>
</listitem>
</itemizedlist>
</blockquote>
<simpara>先ほどの <literal>promise.then</literal> も同様のケースであり、この同期と非同期処理の混在の問題が起きないようにするため、
<emphasis role="strong">Promiseは常に非同期</emphasis> で処理されるという事が仕様で定められているわけです。</simpara>
<simpara>最後に、この <literal>onReady</literal> をPromiseを使って定義すると以下のようになります。</simpara>
<formalpara xml:id="onready-as-promise.js" role="executable">
<title>onready-as-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function onReadyPromise() {
    return new Promise(function (resolve, reject) {
        var readyState = document.readyState;
        if (readyState === 'interactive' || readyState === 'complete') {
            resolve();
        } else {
            window.addEventListener('DOMContentLoaded', resolve);
        }
    });
}
onReadyPromise().then(function () {
    console.log('DOM fully loaded and parsed');
});
console.log('==Starting==');</programlisting>
</para>
</formalpara>
<simpara>Promiseは常に非同期で実行されることが保証されているため、
<literal>setTimeout</literal> のような明示的に非同期処理にするためのコードが不要となることが分かります。</simpara>
</section>
</section>
<section xml:id="ch2-promise.then">
<title>Promise#then</title>
<simpara>先ほどの章でPromiseの基本となるインスタンスメソッドである <literal>then</literal> と <literal>catch</literal> の使い方を説明しました。</simpara>
<simpara>その中で <literal>.then().catch()</literal> とメソッドチェーンで繋げて書いていたことからもわかるように、
Promiseではいくらでもメソッドチェーンを繋げて処理を書いていくことが出来ます。</simpara>
<formalpara>
<title>promiseはメソッドチェーンで繋げて書ける</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">aPromise.then(function taskA(value){
// task A
}).then(function taskB(value){
// task B
}).catch(function onRejected(error){
    console.log(error);
});</programlisting>
</para>
</formalpara>
<simpara><literal>then</literal> で登録するコールバック関数をそれぞれtaskというものにした時に、
taskA &#8594; task B という流れをPromiseのメソッドチェーンを使って書くことが出来ます。</simpara>
<simpara>Promiseのメソッドチェーンだと長いので、今後は<link linkend="promise-chain">promise chain</link>と呼びます。
このpromise chainがPromiseが非同期処理の流れを書きやすい理由の一つといえるかもしれません。</simpara>
<simpara>このセクションでは、<literal>then</literal> を使ったpromise chainの挙動と流れについて学んでいきましょう。</simpara>
<section xml:id="_promise_chain">
<title>promise chain</title>
<simpara>第一章の例だと、<link linkend="promise-chain">promise chain</link>は
then &#8594; catch というシンプルな例でしたが、このpromise chainをもっとつなげた場合に、
それぞれのpromiseオブジェクトに登録された onFulfilledとonRejectedがどのように呼ばれるかを見て行きましょう。</simpara>
<note>
<simpara>promise chain - すなわちメソッドチェーンが短い事は良いことです。
この例では説明のために長いメソッドチェーンを用います。</simpara>
</note>
<simpara>次のようなpromise chainを見てみましょう。</simpara>
<formalpara xml:id="promise-then-catch-flow.js" role="executable">
<title>promise-then-catch-flow.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function taskA() {
    console.log("Task A");
}
function taskB() {
    console.log("Task B");
}
function onRejected(error) {
    console.log("Catch Error: A or B", error);
}
function finalTask() {
    console.log("Final Task");
}

var promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .catch(onRejected)
    .then(finalTask);</programlisting>
</para>
</formalpara>
<simpara>このようなpromise chainをつなげた場合、
それぞれの処理の流れは以下のように図で表せます。</simpara>
<figure xml:id="promise-then-catch-flow.png">
<title>promise-then-catch-flow.jsの図</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/promise-then-catch-flow.png"/>
</imageobject>
<textobject><phrase>promise-then-catch-flow</phrase></textobject>
</mediaobject>
</figure>
<simpara><link linkend="promise-then-catch-flow.js">上記のコード</link>では <literal>then</literal> は第二引数(onRejected)を使っていないため、
以下のように読み替えても問題ありません。</simpara>
<variablelist>
<varlistentry>
<term><literal>then</literal></term>
<listitem>
<simpara>onFulfilledの処理を登録</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>catch</literal></term>
<listitem>
<simpara>onRejectedの処理を登録</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><link linkend="promise-then-catch-flow.png">図</link>の方に注目してもらうと、
<emphasis>Task A</emphasis> と <emphasis>Task B</emphasis> それぞれから <emphasis>onRejected</emphasis> への線が出ていることが分かります。</simpara>
<simpara>これは、<emphasis>Task A</emphasis> または <emphasis>Task B</emphasis> の処理にて、次のような場合に <emphasis>onRejected</emphasis> が呼ばれるという事を示しています。</simpara>
<itemizedlist>
<listitem>
<simpara>例外が発生した時</simpara>
</listitem>
<listitem>
<simpara>Rejectedなpromiseオブジェクトがreturnされた時</simpara>
</listitem>
</itemizedlist>
<simpara><link linkend="how-to-write-promise">第一章</link>でPromiseの処理は常に <literal>try-catch</literal> されているようなものなので、
例外が起きた場合もキャッチして、<literal>catch</literal> で登録された <literal>onRejected</literal> の処理を呼ぶことは学びましたね。</simpara>
<simpara>もう一つの <emphasis>Rejectedなpromiseオブジェクトがreturnされた時</emphasis> については、
<literal>throw</literal> を使わずにpromise chain中に <literal>onRejected</literal> を呼ぶ方法です。</simpara>
<simpara>これについては、ここでは必要ない内容なので詳しくは、 第4章の <link linkend="not-throw-use-reject">throwしないで、rejectしよう</link> にて解説しています。</simpara>
<simpara>また、<emphasis>onRejected</emphasis> と <emphasis>Final Task</emphasis> には <literal>catch</literal> のpromise chainがこれより後ろにありません。
つまり、この処理中に例外が起きた場合はキャッチすることができないことに気をつけましょう。</simpara>
<simpara>もう少し具体的に、<emphasis>Task A</emphasis> &#8594; <emphasis>onRejected</emphasis> となる例を見てみます。</simpara>
<section xml:id="_task_aで例外が発生したケース">
<title>Task Aで例外が発生したケース</title>
<simpara><emphasis>Task A</emphasis> の処理中に例外が発生した場合、
TaskA &#8594; onRejected &#8594; FinalTask という流れで処理が行われます。</simpara>
<figure>
<title>Task Aで例外が発生した時の図</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/promise-taska-rejected-flow.png"/>
</imageobject>
<textobject><phrase>promise taska rejected flow</phrase></textobject>
</mediaobject>
</figure>
<simpara>コードにしてみると以下のようになります。</simpara>
<formalpara xml:id="promise-then-taska-throw.js" role="executable">
<title>promise-then-taska-throw.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function taskA() {
    console.log("Task A");
    throw new Error("throw Error @ Task A");
}
function taskB() {
    console.log("Task B");// 呼ばれない
}
function onRejected(error) {
    console.log(error);// =&gt; "throw Error @ Task A"
}
function finalTask() {
    console.log("Final Task");
}

var promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .catch(onRejected)
    .then(finalTask);</programlisting>
</para>
</formalpara>
<simpara>実行してみると、<emphasis>Task B</emphasis> が呼ばれていない事がわかるでしょう。</simpara>
<note>
<simpara>例では説明のためにtaskAで <literal>throw</literal> して例外を発生させています。
しかし、実際に明示的にonRejectedを呼びたい場合は、Rejectedなpromiseオブジェクトを返すべきでしょう。
それぞれの違いについては <link linkend="not-throw-use-reject">throwしないで、rejectしよう</link> で解説しています。</simpara>
</note>
</section>
</section>
<section xml:id="_promise_chainでの値渡し">
<title>promise chainでの値渡し</title>
<simpara>先ほどの例ではそれぞれのTaskが独立していて、ただ呼ばれているだけでした。</simpara>
<simpara>この時に、Task AがTask Bへ値を渡したい時はどうすれば良いでしょうか?</simpara>
<simpara>答えはものすごく単純でTask Aの処理で <literal>return</literal> した値がTask Bが呼ばれるときに引数に設定されます。</simpara>
<simpara>実際に例を見てみましょう。</simpara>
<formalpara xml:id="promise-then-passing-value.js" role="executable">
<title>promise-then-passing-value.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function doubleUp(value) {
    return value * 2;
}
function increment(value) {
    return value + 1;
}
function output(value) {
    console.log(value);// =&gt; (1 + 1) * 2
}

var promise = Promise.resolve(1);
promise
    .then(increment)
    .then(doubleUp)
    .then(output)
    .catch(function(error){
        // promise chain中にエラーが発生した場合に呼ばれる
        console.error(error);
    });</programlisting>
</para>
</formalpara>
<simpara>スタートは <literal>Promise.resolve(1);</literal> で、この処理は以下のような流れでpromise chainが処理されていきます。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>Promise.resolve(1);</literal> から 1 が <literal>increment</literal> に渡される</simpara>
</listitem>
<listitem>
<simpara><literal>increment</literal> では渡された値に+1した値を <literal>return</literal> している</simpara>
</listitem>
<listitem>
<simpara>この値(2)が次の <literal>doubleUp</literal> に渡される</simpara>
</listitem>
<listitem>
<simpara>最後に <literal>output</literal> が出力する</simpara>
</listitem>
</orderedlist>
<figure>
<title>promise-then-passing-value.jsの図</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/promise-then-passing-value.png"/>
</imageobject>
<textobject><phrase>promise-then-passing-value</phrase></textobject>
</mediaobject>
</figure>
<simpara>この <literal>return</literal> する値は数字や文字列だけではなく、
オブジェクトやpromiseオブジェクトも <literal>return</literal> することが出来ます。</simpara>
<simpara>returnした値は <literal>Promise.resolve(returnされた値);</literal> のように処理されるため、
何をreturnしても最終的には新しいpromiseオブジェクトを返します。</simpara>
<note>
<simpara>これについて詳しくは <link linkend="then-return-new-promise">thenは常に新しいpromiseオブジェクトを返す</link> にて、
よくある間違いと共に紹介しています。</simpara>
</note>
<simpara>つまり、 <literal>Promise#then</literal> は単にコールバックとなる関数を登録するだけではなく、
受け取った値を変化させて別のpromiseオブジェクトを生成する という機能も持っていることを覚えておくといいでしょう。</simpara>
</section>
</section>
<section xml:id="ch2-promise-catch">
<title>Promise#catch</title>
<simpara><link linkend="ch2-promise.then">先ほどのPromise#then</link>についてでも <literal>Promise#catch</literal> は既に使っていましたね。</simpara>
<simpara>改めて説明すると<link linkend="promise.catch">Promise#catch</link>は <literal>promise.then(undefined, onRejected);</literal> のエイリアスとなるメソッドです。
つまり、promiseオブジェクトがRejectedとなった時に呼ばれる関数を登録するためのメソッドです。</simpara>
<note>
<simpara><link linkend="promise.then">Promise#then</link>と<link linkend="promise.catch">Promise#catch</link>の使い分けについては、
<link linkend="then-or-catch">then or catch?</link>で紹介しています。</simpara>
</note>
<section xml:id="_ie8以下での問題">
<title>IE8以下での問題</title>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/promise-catch-error.png"/>
</imageobject>
<textobject><phrase>Build Status</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>このバッジは以下のコードが、 <link xl:href="https://github.com/jakearchibald/es6-promise">polyfill</link> を用いた状態でそれぞれのブラウザで正しく実行できているかを示したものです。</simpara>
<note>
<simpara>polyfillとはその機能が実装されていないブラウザでも、その機能が使えるようにするライブラリのことです。
この例では <link xl:href="https://github.com/jakearchibald/es6-promise">jakearchibald/es6-promise</link> を利用しています。</simpara>
</note>
<formalpara role="executable">
<title>Promise#catchの実行結果</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var promise = Promise.reject(new Error("message"));
promise.catch(function (error) {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>このコードをそれぞれのブラウザで実行させると、IE8以下では実行する段階で <emphasis role="strong">識別子がありません</emphasis> というSyntax Errorになってしまいます。</simpara>
<simpara>これはどういう事かというと、<literal>catch</literal> という単語はECMAScriptにおける <link xl:href="http://mothereff.in/js-properties#catch">予約語</link> であることが関係します。</simpara>
<simpara>ECMAScript 3では予約語はプロパティの名前に使うことが出来ませんでした。
IE8以下はECMAScript 3の実装であるため、<literal>catch</literal> というプロパティを使う <literal>promise.catch()</literal> という書き方が出来ないので、
<emphasis role="strong">識別子がありません</emphasis>というエラーを起こしてしまう訳です。</simpara>
<simpara>一方、現在のブラウザが実装済みであるECMAScript 5以降では、
予約語を <link xl:href="http://es5.github.io/#x7.6">IdentifierName</link> 、つまりプロパティ名に利用することが可能となっています。</simpara>
<note>
<simpara>ECMAScript 5でも予約語は <link xl:href="http://es5.github.io/#x7.6">Identifier</link> 、つまり変数名、関数名には利用することが出来ません。
<literal>for</literal> という変数が定義できてしまうと <literal>for</literal> 文との区別ができなくなってしまいます。
プロパティの場合は <literal>object.for</literal> と <literal>for</literal> 文の区別はできるので、少し考えてみると自然な動作ですね。</simpara>
</note>
<simpara>このECMAScript 3の予約語の問題を回避する書き方も存在します。</simpara>
<simpara><link xl:href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation">ドット表記法</link>
はプロパティ名が有効な識別子(ECMAScript 3の場合は予約語が使えない)でないといけませんが、
<link xl:href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Bracket_notation">ブラケット表記法</link>
は有効な識別子ではなくても利用できます。</simpara>
<simpara>つまり、先ほどのコードは以下のように書き換えれば、IE8以下でも実行することが出来ます。(もちろんpolyfillは必要です)</simpara>
<formalpara role="executable">
<title>Promise#catchの識別子エラーの回避</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var promise = Promise.reject(new Error("message"));
promise["catch"](function (error) {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>もしくは単純に <literal>catch</literal> を使わずに、<literal>then</literal> を使うことでも回避できます。</simpara>
<formalpara role="executable">
<title>Promise#catchではなくPromise#thenを使う</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var promise = Promise.reject(new Error("message"));
promise.then(undefined, function (error) {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><literal>catch</literal> という識別子が問題となっているため、ライブラリによっては <literal>caught</literal> 等の名前が違うだけのメソッドを用意しているケースがあります。</simpara>
<simpara>また多くの圧縮ツールは <literal>promise.catch</literal> を <literal>promise["catch"]</literal> へと置換する処理が組み込まれているため、知らない間に回避出来ていることも多いかも知れません。</simpara>
<simpara>サポートブラウザにIE8以下を含める時は、この <literal>catch</literal> の問題に気をつけるといいでしょう。</simpara>
</section>
</section>
<section xml:id="then-return-new-promise">
<title>コラム: thenは常に新しいpromiseオブジェクトを返す</title>
<simpara><literal>aPromise.then(&#8230;&#8203;).catch(&#8230;&#8203;)</literal> は一見すると、全て最初の <literal>aPromise</literal> オブジェクトに
メソッドチェーンで処理を書いてるように見えます。</simpara>
<simpara>しかし、実際には <literal>then</literal> で新しいpromiseオブジェクト、<literal>catch</literal> でも別の新しいpromiseオブジェクトを作成して返しています。</simpara>
<simpara>本当に新しいpromiseオブジェクトを返しているのか確認してみましょう。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">var aPromise = new Promise(function (resolve) {
    resolve(100);
});
var thenPromise = aPromise.then(function (value) {
    console.log(value);
});
var catchPromise = thenPromise.catch(function (error) {
    console.error(error);
});
console.log(aPromise !== thenPromise); // =&gt; true
console.log(thenPromise !== catchPromise);// =&gt; true</programlisting>
<simpara><literal>===</literal> 厳密比較演算子によって比較するとそれぞれが別々のオブジェクトなので、
本当に <literal>then</literal> や <literal>catch</literal> は別のpromiseオブジェクトを返していることが分かりました。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/then_catch.png"/>
</imageobject>
<textobject><phrase>Then Catch flow</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>この仕組みはPromiseを拡張する時は意識しないと、いつのまにか触ってるpromiseオブジェクトが
別のものであったという事が起こりえると思います。</simpara>
<simpara>また、<literal>then</literal> は新しいオブジェクトを作って返すということがわかっていれば、
次の <literal>then</literal> の使い方では意味が異なる事に気づくでしょう。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">// 1: それぞれの `then` は同時に呼び出される
var aPromise = new Promise(function (resolve) {
    resolve(100);
});
aPromise.then(function (value) {
    return value * 2;
});
aPromise.then(function (value) {
    return value * 2;
});
aPromise.then(function (value) {
    console.log("1: " + value); // =&gt; 100
})

// vs

// 2: `then` はpromise chain通り順番に呼び出される
var bPromise = new Promise(function (resolve) {
    resolve(100);
});
bPromise.then(function (value) {
    return value * 2;
}).then(function (value) {
    return value * 2;
}).then(function (value) {
    console.log("2: " + value); // =&gt; 100 * 2 * 2
});</programlisting>
<simpara>1のpromiseをメソッドチェーン的に繋げない書き方はあまりすべきではありませんが、
このような書き方をした場合、それぞれの <literal>then</literal> はほぼ同時に呼ばれ、また <literal>value</literal> に渡る値も全て同じ <literal>100</literal> となります。</simpara>
<simpara>2はメソッドチェーン的につなげて書くことにより、resolve &#8594; then &#8594; then &#8594; then と書いた順番にキチンと実行され、
それぞれの <literal>value</literal> に渡る値は、一つ前のpromiseオブジェクトで <literal>return</literal> された値が渡ってくるようになります。</simpara>
<simpara>1の書き方により発生するアンチパターンとしては以下のようなものが有名です。</simpara>
<formalpara>
<title>✘ <literal>then</literal> の間違った使い方</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function badAsyncCall() {
    var promise = Promise.resolve();
    promise.then(function() {
        // 何かの処理
        return newVar;
    });
    return promise;
}</programlisting>
</para>
</formalpara>
<simpara>このように書いてしまうと、<literal>promise.then</literal> の中で例外が発生するとその例外を取得する方法がなくなり、
また、何かの値を返していてもそれを受け取る方法が無くなってしまいます。</simpara>
<simpara>これは <literal>promise.then</literal> によって新たに作られたpromiseオブジェクトを返すようにすることで、
2のようにpromise chainをつなげるようにするべきなので、次のように修正することが出来ます。</simpara>
<formalpara>
<title><literal>then</literal> で作成したオブジェクトを返す</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function anAsyncCall() {
    var promise = Promise.resolve();
    return promise.then(function() {
        // 何かの処理
        return newVar;
    });
}</programlisting>
</para>
</formalpara>
<simpara>これらのアンチパターンについて、詳しくは
<link xl:href="http://taoofcode.net/promise-anti-patterns/">Promise Anti-patterns</link> を参照して下さい。</simpara>
<simpara>この挙動はPromise全般に当てはまるため、後に説明する<link linkend="ch2-promise-all">Promise.all</link>や<link linkend="ch2-promise-race">Promise.race</link>も
引数で受け取ったものとは別のpromiseオブジェクトを作って返しています。</simpara>
</section>
<section xml:id="ch2-promise-and-array">
<title>Promiseと配列</title>
<simpara>ここまでで、promiseオブジェクトが FulFilled または Rejected となった時の処理は <link linkend="promise.then"><literal>.then</literal></link> と <link linkend="promise.catch"><literal>.catch</literal></link> で登録出来る事を学びました。</simpara>
<simpara>一つのpromiseオブジェクトなら、そのpromiseオブジェクトに対して処理を書けば良いですが、
複数のpromiseオブジェクトが全てFulFilledとなった時の処理を書く場合はどうすればよいでしょうか?</simpara>
<simpara>例えば、複数のXHR(非同期処理)が全て終わった後に、何かをしたいという事例を考えてみます。</simpara>
<simpara>少しイメージしにくいので、
まずは、通常のコールバックスタイルを使って複数のXHRを行う以下のようなコードを見てみます。</simpara>
<section xml:id="_コールバックで複数の非同期処理">
<title>コールバックで複数の非同期処理</title>
<formalpara xml:id="multiple-xhr-callback.js" role="executable">
<title>multiple-xhr-callback.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function getURLCallback(URL, callback) {
    var req = new XMLHttpRequest();
    req.open('GET', URL, true);
    req.onload = function () {
        if (req.status === 200) {
            callback(null, req.responseText);
        } else {
            callback(new Error(req.statusText), req.response);
        }
    };
    req.onerror = function () {
        callback(new Error(req.statusText));
    };
    req.send();
}
// &lt;1&gt; JSONパースを安全に行う
function jsonParse(callback, error, value) {
    if (error) {
        callback(error, value);
    } else {
        try {
            var result = JSON.parse(value);
            callback(null, result);
        } catch (e) {
            callback(e, value);
        }
    }
}
// &lt;2&gt; XHRを叩いてリクエスト
var request = {
        comment: function getComment(callback) {
            return getURLCallback('http://azu.github.io/promises-book/json/comment.json', jsonParse.bind(null, callback));
        },
        people: function getPeople(callback) {
            return getURLCallback('http://azu.github.io/promises-book/json/people.json', jsonParse.bind(null, callback));
        }
    };
// &lt;3&gt; 複数のXHRリクエストを行い、全部終わったらcallbackを呼ぶ
function allRequest(requests, callback, results) {
    if (requests.length === 0) {
        return callback(null, results);
    }
    var req = requests.shift();
    req(function (error, value) {
        if (error) {
            callback(error, value);
        } else {
            results.push(value);
            allRequest(requests, callback, results);
        }
    });
}
function main(callback) {
    allRequest([request.comment, request.people], callback, []);
}
// 実行例
main(function(error, results){
    if(error){
        console.error(error);
        return;
    }
    console.log(results);
});</programlisting>
</para>
</formalpara>
<simpara>このコールバックスタイルでは幾つかの要素が出てきます。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>JSON.parse</literal> をそのまま使うと例外となるケースがあるためラップした <literal>jsonParse</literal> 関数を使う</simpara>
</listitem>
<listitem>
<simpara>複数のXHRをそのまま書くとネストが深くなるため、<literal>allRequest</literal> というrequest関数を実行するものを利用する</simpara>
</listitem>
<listitem>
<simpara>コールバック関数には <literal>callback(error,value)</literal> のように第一引数にエラー、第二引数にレスポンスを渡す。</simpara>
</listitem>
</itemizedlist>
<simpara><literal>jsonParse</literal> 関数を使うときに <literal>bind</literal> を使うことで、部分適用を使って無名関数を減らすようにしています。
(コールバックスタイルでも関数の処理などをちゃんと分離すれば、無名関数の使用も減らせると思います)</simpara>
<programlisting language="javascript" linenumbering="unnumbered">jsonParse.bind(null, callback);
// は以下のように置き換えるのと殆ど同じ
function bindJSONParse(error, value){
    jsonParse(callback, error, value);
}</programlisting>
<simpara>コールバックスタイルで書いたものを見ると以下のような点が気になります。</simpara>
<itemizedlist>
<listitem>
<simpara>明示的な例外のハンドリングが必要</simpara>
</listitem>
<listitem>
<simpara>ネストを深くしないために、requestを扱う関数が必要</simpara>
</listitem>
<listitem>
<simpara>コールバックがたくさんでてくる</simpara>
</listitem>
</itemizedlist>
<simpara>次は、<literal>Promise#then</literal> を使って同様の事をしてみたいと思います。</simpara>
</section>
<section xml:id="_promise_thenのみで複数の非同期処理">
<title>Promise#thenのみで複数の非同期処理</title>
<simpara>先に述べておきますが、<literal>Promise.all</literal> というこのような処理に適切なものがあるため、
ワザと <literal>.then</literal> の部分をクドく書いています。</simpara>
<simpara><link linkend="promise.then"><literal>.then</literal></link> を使った場合は、コールバックスタイルと完全に同等というわけではないですが以下のように書けると思います。</simpara>
<formalpara xml:id="multiple-xhr.js" role="executable">
<title>multiple-xhr.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function getURL(URL) {
    return new Promise(function (resolve, reject) {
        var req = new XMLHttpRequest();
        req.open('GET', URL, true);
        req.onload = function () {
            if (req.status === 200) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = function () {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
var request = {
        comment: function getComment() {
            return getURL('http://azu.github.io/promises-book/json/comment.json').then(JSON.parse);
        },
        people: function getPeople() {
            return getURL('http://azu.github.io/promises-book/json/people.json').then(JSON.parse);
        }
    };
function main() {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }
    // [] は記録する初期値を部分適用している
    var pushValue = recordValue.bind(null, []);
    return request.comment().then(pushValue).then(request.people).then(pushValue);
}
// 実行例
main().then(function (value) {
    console.log(value);
}).catch(function(error){
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><link linkend="multiple-xhr-callback.js">コールバックスタイル</link>と比較してみると次の事がわかります。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>JSON.parse</literal> をそのまま使っている</simpara>
</listitem>
<listitem>
<simpara><literal>main()</literal> はpromiseオブジェクトを返している</simpara>
</listitem>
<listitem>
<simpara>エラーハンドリングは返ってきたpromiseオブジェクトに対して書いている</simpara>
</listitem>
</itemizedlist>
<simpara>先ほども述べたように mainの <literal>then</literal> の部分がクドく感じます。</simpara>
<simpara>Promiseでは、このような複数の非同期処理をまとめて扱う <literal>Promise.all</literal> と <literal>Promise.race</literal> という静的メソッドが用意されています。</simpara>
<simpara>次のセクションではそれらについて学んでいきましょう。</simpara>
</section>
</section>
<section xml:id="ch2-promise-all">
<title>Promise.all</title>
<simpara><link linkend="Promise.all"><literal>Promise.all</literal></link> は promiseオブジェクトの配列を受け取り、
その配列に入っているpromiseオブジェクトが全てresolveされた時に、次の <literal>.then</literal> を呼び出します。</simpara>
<simpara>先ほどの複数のXHRの結果をまとめて取得する処理は、 <link linkend="Promise.all"><literal>Promise.all</literal></link> を使うとシンプルに書くことができます。</simpara>
<simpara>先ほどの例の <literal>getURL</literal> はXHRによる通信を抽象化したpromiseオブジェクトを返しています。
<literal>Promise.all</literal> に通信を抽象化したpromiseオブジェクトの配列を渡すことで、
全ての通信が完了(FulFilledまたRejected)した時に、次の <literal>.then</literal> を呼び出すことが出来ます。</simpara>
<formalpara xml:id="promise-all-xhr.js" role="executable">
<title>promise-all-xhr.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function getURL(URL) {
    return new Promise(function (resolve, reject) {
        var req = new XMLHttpRequest();
        req.open('GET', URL, true);
        req.onload = function () {
            if (req.status === 200) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = function () {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
var request = {
        comment: function getComment() {
            return getURL('http://azu.github.io/promises-book/json/comment.json').then(JSON.parse);
        },
        people: function getPeople() {
            return getURL('http://azu.github.io/promises-book/json/people.json').then(JSON.parse);
        }
    };
function main() {
    return Promise.all([request.comment(), request.people()]);
}
// 実行例
main().then(function (value) {
    console.log(value);
}).catch(function(error){
    console.log(error);
});</programlisting>
</para>
</formalpara>
<simpara>実行方法は <link linkend="xhr-promise.js">前回のもの</link> と同じですね。
<link linkend="Promise.all"><literal>Promise.all</literal></link> を使うことで以下のような違いがあることがわかります。</simpara>
<itemizedlist>
<listitem>
<simpara>mainの処理がスッキリしている</simpara>
</listitem>
<listitem>
<simpara>Promise.all は promiseオブジェクトの配列を扱っている</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">Promise.all([request.comment(), request.people()]);</programlisting>
<simpara>というように処理を書いた場合は、<literal>request.comment()</literal> と <literal>request.people()</literal> は同時に実行されますが、
それぞれのpromiseの結果(resolve,rejectで渡される値)は、<link linkend="Promise.all"><literal>Promise.all</literal></link>に渡した配列の順番となります。</simpara>
<simpara>つまり、この場合に次の <literal>.then</literal> に渡される結果の配列は [comment, people]の順番になることが保証されています。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">main().then(function (results) {
    console.log(results); // [comment, people]の順番
});</programlisting>
<simpara><link linkend="Promise.all"><literal>Promise.all</literal></link> に渡したpromiseオブジェクトが同時に実行されてるのは、
次のようなタイマーを使った例を見てみると分かりやすいです。</simpara>
<formalpara xml:id="promise-all-timer.js" role="executable">
<title>promise-all-timer.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">// `delay`ミリ秒後にresolveする
function timerPromisefy(delay) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            resolve(delay);
        }, delay);
    });
}
var startDate = Date.now();
// 全てがresolveされたら終了
Promise.all([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
]).then(function (values) {
    console.log(Date.now() - startDate + 'ms');
    // 約128ms
    console.log(values);    // [1,32,64,128]
});</programlisting>
</para>
</formalpara>
<simpara><literal>timerPromisefy</literal> は引数で指定したミリ秒後に、その指定した値でFulFilledとなる
promiseオブジェクトを返してくれます。</simpara>
<simpara><literal>Promise.all</literal> に渡してるのは、それを複数作り配列にしたものですね。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var promises = [
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
];</programlisting>
<simpara>この場合は、1, 32, 64, 128 ミリ秒後にそれぞれ <literal>resolve</literal> されます。</simpara>
<simpara>つまり、このpromiseオブジェクトの配列がすべてresolveされるには、最低でも128msかかることがわかります。
実際に<link linkend="Promise.all"><literal>Promise.all</literal></link> で処理してみると 約128msかかる事がわかります。</simpara>
<simpara>この事から、<link linkend="Promise.all"><literal>Promise.all</literal></link> が一つづつ順番にやるわけではなく、
渡されたpromiseオブジェクトの配列を並列に実行してるという事がわかります。</simpara>
<note>
<simpara>仮に逐次的に行われていた場合は、
1ms待機 &#8594; 32ms待機 &#8594; 64ms待機 &#8594; 128ms待機 となるので、
全て完了するまで225ms程度かかる計算になります。</simpara>
<simpara>実際にPromiseを逐次的に処理したいケースについては第4章の<link linkend="promise-sequence">Promiseによる逐次処理</link>を参照して下さい。</simpara>
</note>
</section>
<section xml:id="ch2-promise-race">
<title>Promise.race</title>
<simpara><link linkend="Promise.all"><literal>Promise.all</literal></link> と同様に複数のpromiseオブジェクトを扱う<link linkend="Promise.race"><literal>Promise.race</literal></link>を見てみましょう。</simpara>
<simpara>使い方はPromise.allと同様で、promiseオブジェクトの配列を引数に渡します。</simpara>
<simpara><literal>Promise.all</literal> は、渡した全てのpromiseがFulFilled または Rejectedになるまで次の処理を待ちましたが、
<literal>Promise.race</literal> は、どれか一つでもpromiseがFulFilled または Rejectedになったら次の処理を実行します。</simpara>
<simpara>Promise.allの時と同じく、タイマーを使った <literal>Promise.race</literal> の例を見てみましょう</simpara>
<formalpara xml:id="promise-race-timer.js" role="executable">
<title>promise-race-timer.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">// `delay`ミリ秒後にresolveする
function timerPromisefy(delay) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            resolve(delay);
        }, delay);
    });
}
// 一つでもresolve または reject した時点で終了
Promise.race([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
]).then(function (value) {
    console.log(value);    // =&gt; 1
});</programlisting>
</para>
</formalpara>
<simpara>上記のコードだと、1ms後、32ms後、64ms後、128ms後にそれぞれpromiseオブジェクトがFulFilledとなりますが、
一番最初に1msのものがFulFilledとなった時点で、<literal>.then</literal> が呼ばれます。
また、<literal>resolve(1)</literal> が呼ばれるため <literal>value</literal> に渡される値も1となります。</simpara>
<simpara>最初にFulFilledとなったpromiseオブジェクト以外は、その後呼ばれているのかを見てみましょう。</simpara>
<formalpara xml:id="promise-race-other.js" role="executable">
<title>promise-race-other.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var winnerPromise = new Promise(function (resolve) {
        setTimeout(function () {
            console.log('this is winner');
            resolve('this is winner');
        }, 4);
    });
var loserPromise = new Promise(function (resolve) {
        setTimeout(function () {
            console.log('this is loser');
            resolve('this is loser');
        }, 1000);
    });
// 一番最初のものがresolveされた時点で終了
Promise.race([winnerPromise, loserPromise]).then(function (value) {
    console.log(value);    // =&gt; 'this is winner'
});</programlisting>
</para>
</formalpara>
<simpara>先ほどのコードに <literal>console.log</literal> をそれぞれ追加しただけの内容となっています。</simpara>
<simpara>実行してみると、winnter/loser どちらも <literal>setTimeout</literal> の中身が実行されて <literal>console.log</literal> がそれぞれ出力されている事がわかります。</simpara>
<simpara>つまり、<link linkend="Promise.race"><literal>Promise.race</literal></link>では、
一番最初のpromiseオブジェクトがFulfilledとなっても、他のpromiseがキャンセルされるわけでは無いという事がわかります。</simpara>
<note>
<simpara><link linkend="es6-promises">ES6 Promises</link>の仕様には、キャンセルという概念はありません。
必ず、resolve or rejectによる状態の解決が起こることが前提となっています。
つまり、<link linkend="promise-states">状態</link>が固定されてしまうかもしれない処理には不向きであると言えます。
ライブラリによってはキャンセルを行う仕組みが用意されている場合があります。</simpara>
</note>
</section>
<section xml:id="then-or-catch">
<title>then or catch?</title>
<simpara><link linkend="catch-as-alias">前の章</link>で <link linkend="promise.catch"><literal>.catch</literal></link> は  <literal>promise.then(undefined, onRejected)</literal> であるという事を紹介しました。</simpara>
<simpara>この書籍では基本的には、<link linkend="promise.catch"><literal>.catch</literal></link>を使い <link linkend="promise.then"><literal>.then</literal></link> とは分けてエラーハンドリングを書くようにしています。</simpara>
<simpara>ここでは、<literal>.then</literal> でまとめて指定した場合と、どのような違いがでるかについて学んでいきましょう。</simpara>
<section xml:id="_エラー処理ができないonrejected">
<title>エラー処理ができないonRejected</title>
<simpara>次のようなコードを見ていきます。</simpara>
<formalpara xml:id="then-throw-error.js" role="executable">
<title>then-throw-error.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function throwError(value) {
    // 例外を投げる
    throw new Error(value);
}
// &lt;1&gt; onRejectedが呼ばれることはない
function badMain(onRejected) {
    return Promise.resolve(42).then(throwError, onRejected);
}
// &lt;2&gt; onRejectedが例外発生時に呼ばれる
function goodMain(onRejected) {
    return Promise.resolve(42).then(throwError).catch(onRejected);
}
// 実行例
badMain(function(){
    console.log("BAD");
});
goodMain(function(){
    console.log("GOOD");
});</programlisting>
</para>
</formalpara>
<simpara>このコード例では、(必ずしも悪いわけではないですが)良くないパターンの <literal>badMain</literal> と
ちゃんとエラーハンドリングが行える <literal>goodMain</literal> があります。</simpara>
<simpara><literal>badMain</literal> がなぜ良くないかというと、<literal>.then</literal> の第二引数にはエラー処理を書くことが出来ますが、
そのエラー処理は第一引数の <literal>onFulfilled</literal> で指定した関数内で起きたエラーをキャッチする事は出来ません。</simpara>
<simpara>つまり、この場合、 <literal>throwError</literal> でエラーがおきても、<literal>onRejected</literal> に指定した関数は呼ばれることなく、
どこでエラーが発生したのかわからなくなってしまいます。</simpara>
<simpara>それに対して、 <literal>goodMain</literal> は <literal>throwError</literal> &#8594; <literal>onRejected</literal> となるように書かれています。
この場合は <literal>throwError</literal> でエラーが発生しても、次のchainである <literal>.catch</literal> が呼ばれるため、エラーハンドリングを行う事が出来ます。</simpara>
<simpara><literal>.then</literal> のonRejectedが扱う処理は、その(またはそれ以前の)promiseオブジェクトに対してであって、
<literal>.then</literal> に書かれたonFulfilledは対象ではないためこのような違いが生まれます。</simpara>
<note>
<simpara><literal>.then</literal> や <literal>.catch</literal> はその場で<emphasis role="strong">新しい</emphasis>promiseオブジェクトを作って返します。
Promiseではchainする度に異なるpromiseオブジェクトに対して処理を書くようになっています。</simpara>
</note>
<figure xml:id="then-catch-flow">
<title>Then Catch flow</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/then_catch.png"/>
</imageobject>
<textobject><phrase>Then Catch flow</phrase></textobject>
</mediaobject>
</figure>
<simpara>この場合の <literal>then</literal> は <literal>Promise.resolve(42)</literal> に対する処理となり、
<literal>onFulfilled</literal> で例外が発生しても、同じ <literal>then</literal> で指定された <literal>onRejected</literal> はキャッチすることはありません。</simpara>
<simpara>この <literal>then</literal> で発生した例外をキャッチ出来るのは、次のchainで書かれた <literal>catch</literal> となります。</simpara>
<simpara>もちろん <literal>.catch</literal> は <literal>.then</literal> のエイリアスなので、下記のように <literal>.then</literal> を使っても問題はありませんが、
<literal>.catch</literal> を使ったほうが意図が明確で分かりやすいでしょう。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">Promise.resolve(42).then(throwError).then(null, onRejected);</programlisting>
</section>
<section xml:id="_まとめ_2">
<title>まとめ</title>
<simpara>ここでは次のような事について学びました。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>promise.then(onFulfilled, onRejected)</literal> において</simpara>
<itemizedlist>
<listitem>
<simpara><literal>onFulfilled</literal> で例外がおきても、この <literal>onRejected</literal> はキャッチできない</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>promise.then(onFulfilled).catch(onRejected)</literal> とした場合</simpara>
<itemizedlist>
<listitem>
<simpara><literal>then</literal> で発生した例外を <literal>.catch</literal> でキャッチできる</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><link linkend="promise.then"><literal>.then</literal></link>と<link linkend="promise.catch"><literal>.catch</literal></link>に本質的な意味の違いはない</simpara>
<itemizedlist>
<listitem>
<simpara>使い分けると意図が明確になる</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara><literal>badMain</literal> のような書き方をすると、意図とは異なりエラーハンドリングができないケースが存在することは覚えておきましょう。</simpara>
</section>
</section>
</section>
<section xml:id="chapter3-promise-testing">
<title>Chapter.3 - Promiseのテスト</title>
<simpara>この章ではPromiseのテストの書き方について学んで行きます。</simpara>
<section xml:id="basic-tests">
<title>基本的なテスト</title>
<simpara><link linkend="es6-promises">ES6 Promises</link>のメソッド等についてひと通り学ぶことができたため、
実際にPromiseを使った処理を書いていくことは出来ると思います。</simpara>
<simpara>そうした時に、次にどうすればいいのか悩むのがPromiseのテストの書き方です。</simpara>
<simpara>ここではまず、 <link xl:href="http://mochajs.org/">Mocha</link>を使った基本的なPromiseのテストの書き方について学んでいきましょう。</simpara>
<simpara>また、この章でのテストコードはNode.js環境で実行することを前提としているため、
各自Node.js環境を用意してください。</simpara>
<note>
<simpara>この書籍中に出てくるサンプルコードはそれぞれテストも書かれています。
テストコードは <link xl:href="https://github.com/azu/promises-book">azu/promises-book</link> から参照できます。</simpara>
</note>
<section xml:id="_mochaとは">
<title>Mochaとは</title>
<simpara>Mochaの公式サイト: <link xl:href="http://mochajs.org/">http://mochajs.org/</link></simpara>
<simpara>ここでは、 Mocha自体については詳しく解説しませんが、
MochaはNode.js製のテストフレームワークツールです。</simpara>
<simpara>MochaはBDD,TDD,exportsのどれかのスタイルを選択でき、テストに使うアサーションメソッドも任意のライブラリと組み合わせて利用します。
つまり、Mocha自体はテスト実行時の枠だけを提供しており、他は利用者が選択するというものになっています。</simpara>
<simpara>Mochaを選択した理由は、以下の通りです。</simpara>
<itemizedlist>
<listitem>
<simpara>著名なテストフレームワークであること</simpara>
</listitem>
<listitem>
<simpara>Node.jsとブラウザ どちらのテストもサポートしている</simpara>
</listitem>
<listitem>
<simpara>"Promiseのテスト"をサポートしている</simpara>
</listitem>
</itemizedlist>
<simpara>最後の <emphasis>"Promiseのテスト"をサポートしている</emphasis> とはどういうことなのかについては後ほど解説します。</simpara>
<simpara>この章ではMochaを利用するため、npmを使いMochaをインストールしておく必要があります。</simpara>
<programlisting language="console" linenumbering="unnumbered">$ npm install -g mocha</programlisting>
<simpara>また、アサーション自体はNode.jsに同梱されている <literal>assert</literal> モジュールを使用するので別途インストールは必要ありません。</simpara>
<simpara>まずはコールバックスタイルの非同期処理をテストしてみましょう。</simpara>
</section>
<section xml:id="_コールバックスタイルのテスト">
<title>コールバックスタイルのテスト</title>
<simpara>コールバックスタイルの非同期処理をテストする場合、Mochaでは以下のように書くことが出来ます。</simpara>
<formalpara>
<title>basic-test.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var assert = require('assert');
it('should use `done` for test', function (done) {
    setTimeout(function () {
        assert(true);
        done();
    }, 0);
});</programlisting>
</para>
</formalpara>
<simpara>このテストを <literal>basic-test.js</literal> というファイル名で作成し、
先ほどインストールしたMochaでコマンドラインからテストを実行することが出来ます。</simpara>
<programlisting language="sh" linenumbering="unnumbered">$ mocha basic-test.js</programlisting>
<simpara>Mochaは <literal>it</literal> の仮引数に <literal>done</literal> のように指定してあげると、
<literal>done()</literal> が呼ばれるまでテストの終了を待つことで非同期のテストをサポートしています。</simpara>
<simpara>Mochaでの非同期テストは以下のような流れで実行されます。</simpara>
<programlisting xml:id="callback-style-test" language="javascript" linenumbering="unnumbered">it("should use `done` for test", function (done) {
    <co xml:id="CO7-1"/>
    setTimeout(function () {
        assert(true);
        done();<co xml:id="CO7-2"/>
    }, 0);
});</programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>コールバックを使う非同期処理</para>
</callout>
<callout arearefs="CO7-2">
<para><literal>done</literal> を呼ぶことでテストが終了する</para>
</callout>
</calloutlist>
<simpara>よく見かける形の書き方ですね。</simpara>
</section>
<section xml:id="done-promise-test">
<title><literal>done</literal> を使ったPromiseのテスト</title>
<simpara>次に、同じく <literal>done</literal> を使ったPromiseのテストを書いてみましょう。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">it("should use `done` for test?", function (done) {
    var promise = Promise.resolve(42);<co xml:id="CO8-1"/>
    promise.then(function (value) {
        assert(value === 42);
        done();<co xml:id="CO8-2"/>
    });
});</programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para><literal>Fulfilled</literal> となるpromiseオブジェクトを作成</para>
</callout>
<callout arearefs="CO8-2">
<para><literal>done</literal> を呼ぶことでテストの終了を宣言</para>
</callout>
</calloutlist>
<simpara><link linkend="Promise.resolve"><literal>Promise.resolve</literal></link> はpromiseオブジェクトを返しますが、
そのpromiseオブジェクトはFulFilledの状態になります。
その結果として <literal>.then</literal> で登録したコールバック関数が呼び出されます。</simpara>
<simpara><link linkend="promise-is-always-async">コラム: Promiseは常に非同期?</link> でも出てきたように、
promiseオブジェクトは常に非同期で処理されるため、テストも非同期に対応した書き方が必要となります。</simpara>
<simpara>しかし、先ほどのテストコードでは <literal>assert</literal> が失敗した場合に問題が発生します。</simpara>
<formalpara xml:id="promise-assert-fail">
<title>意図しない結果となるPromiseのテスト</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">it("should use `done` for test?", function (done) {
    var promise = Promise.resolve();
    promise.then(function (value) {
        assert(false);// =&gt; throw AssertionError
        done();
    });
});</programlisting>
</para>
</formalpara>
<simpara>このテストは <literal>assert</literal> が失敗しているため、「テストは失敗する」と思うかもしれませんが、
実際にはテストが終わることがなくタイムアウトします。</simpara>
<figure>
<title>テストが終わることがないためタイムアウトするまでそこで止まる</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch3_Testing/img/promise-test-timeout.png"/>
</imageobject>
<textobject><phrase>promise test timeout</phrase></textobject>
</mediaobject>
</figure>
<simpara><literal>assert</literal> が失敗した場合は通常はエラーをthrowし、
テストフレームワークがそれをキャッチすることで、テストが失敗したと判断します。</simpara>
<simpara>しかし、Promiseの場合は <literal>.then</literal> の中で行われた処理でエラーが発生しても、
Promiseがそれをキャッチしてしまい、テストフレームワークまでエラーが届きません。</simpara>
<simpara><link linkend="promise-assert-fail">意図しない結果となるPromiseのテスト</link>を改善して、
<literal>assert</literal> が失敗した場合にちゃんとテストが失敗となるようにしてみましょう。</simpara>
<formalpara xml:id="promise-assert-fail-fixed">
<title>意図通りにテストが失敗する例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">it("should use `done` for test?", function (done) {
    var promise = Promise.resolve();
    promise.then(function (value) {
        assert(false);
    }).then(done, done);
});</programlisting>
</para>
</formalpara>
<simpara>ちゃんとテストが失敗する例では、必ず <literal>done</literal> が呼ばれるようにするため、
最後に <literal>.then(done, done);</literal> を追加しています。</simpara>
<simpara><literal>assert</literal> がパスした場合は単純に <literal>done()</literal> が呼ばれ、<literal>assert</literal> が失敗した場合は <literal>done(error)</literal> が呼ばれます。</simpara>
<simpara>これでようやく<link linkend="callback-style-test">コールバックスタイルのテスト</link>と同等のPromiseのテストを書くことができました。</simpara>
<simpara>しかし、<literal>assert</literal> が失敗した時のために <literal>.then(done, done);</literal> というものを付ける必要があります。
Promiseのテストを書くときにつけ忘れてしまうと終わらないテストが出来上がってしまう場合があることに気をつけましょう。</simpara>
<simpara>次に、最初にmochaを使う理由に上げた"Promisesのテスト"をサポートしているという事がどういう機能なのかを学んでいきましょう。</simpara>
</section>
</section>
<section xml:id="mocha-promise">
<title>MochaのPromiseサポート</title>
<simpara>Mochaがサポートしてる"Promiseのテスト"とは何かについて学んでいきましょう。</simpara>
<simpara>公式サイトの <link xl:href="http://mochajs.org/#asynchronous-code">Asynchronous code</link>にもその概要が書かれています。</simpara>
<blockquote>
<simpara>Alternately, instead of using the done() callback, you can return a promise. This is useful if the APIs you are testing return promises instead of taking callbacks:</simpara>
</blockquote>
<simpara>Promiseのテストの場合はコールバックとして <literal>done()</literal> を呼ぶ代わりに、promiseオブジェクトをreturnすることが出来ると書いてあります。</simpara>
<simpara>では、実際にどのように書くかの例を見て行きたいと思います。</simpara>
<formalpara xml:id="mocha-promise-test.js">
<title>mocha-promise-test.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var assert = require('assert');
describe('Promise Test', function () {
    it('should return a promise object', function () {
        var promise = Promise.resolve(42);
        return promise.then(function (value) {
            assert(value === 42);
        });
    });
});</programlisting>
</para>
</formalpara>
<simpara><link linkend="promise-assert-fail-fixed">先ほどの <literal>done</literal> を使った例</link>をMochaのPromiseテストの形式に変更しました。</simpara>
<simpara>変更点としては以下の2つとなっています。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>done</literal> そのものを取り除いた</simpara>
</listitem>
<listitem>
<simpara>promiseオブジェクトを返すようにした</simpara>
</listitem>
</itemizedlist>
<simpara>この書き方をした場合、<literal>assert</literal> が失敗した場合はもちろんテストが失敗します。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">it("should be fail", function () {
    return Promise.resolve().then(function () {
        assert(false);// =&gt; テストが失敗する
    });
});</programlisting>
<simpara>これにより <literal>.then(done, done);</literal> というような本質的にはテストとは関係ない記述を省くことが出来るようになりました。</simpara>
<note>
<simpara><link xl:href="http://efcl.info/2014/0314/res3708/">MochaがPromisesのテストをサポートしました | Web scratch</link> という記事でも
MochaのPromiseサポートについて書かれています。</simpara>
</note>
<section xml:id="_意図しないテスト結果">
<title>意図しないテスト結果</title>
<simpara>MochaがPromiseのテストをサポートしているため、この書き方で良いと思われるかもしれません。
しかし、この書き方にも意図しない結果になる例外が存在します。</simpara>
<simpara>例えば、以下はある条件だとRejectedなpromiseオブジェクトを返す <literal>mayBeRejected()</literal> のテストコードです。</simpara>
<formalpara xml:id="mocha-rejected-promise-test">
<title>エラーオブジェクトをテストしたい</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function mayBeRejected(){ <co xml:id="CO9-1"/>
    return Promise.reject(new Error("woo"));
}
it("is bad pattern", function () {
    return mayBeRejected().catch(function (error) {
        assert(error.message === "woo");
    });
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO9-1">
<para>この関数が返すpromiseオブジェクトをテストしたい</para>
</callout>
</calloutlist>
<simpara>このテストの目的とは以下のようになっています。</simpara>
<variablelist>
<varlistentry>
<term><literal>mayBeRejected()</literal> が返すpromiseオブジェクトがFulFilledとなった場合</term>
<listitem>
<simpara>テストを失敗させる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>mayBeRejected()</literal> が返すpromiseオブジェクトがRejectedとなった場合</term>
<listitem>
<simpara><literal>assert</literal> でErrorオブジェクトをチェックする</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>上記のテストコードでは、Rejectedとなって <literal>onRejected</literal> に登録された関数が呼ばれるためテストはパスしますね。</simpara>
<simpara>このテストで問題になるのは <literal>mayBeRejected()</literal> で返されたpromiseオブジェクトが
<emphasis role="strong">FulFilledとなった場合</emphasis>に、必ずテストがパスしてしまうという問題が発生します。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">function mayBeRejected(){ <co xml:id="CO10-1"/>
    return Promise.resolve();
}
it("is bad pattern", function () {
    return mayBeRejected().catch(function (error) {
        assert(error.message === "woo");
    });
});</programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para>返されるpromiseオブジェクトはFulFilledとなる</para>
</callout>
</calloutlist>
<simpara>この場合、<literal>catch</literal> で登録した <literal>onRejected</literal> の関数はそもそも呼ばれないため、
<literal>assert</literal> がひとつも呼ばれることなくテストが必ずパスしてしまいます。</simpara>
<simpara>これを解消しようとして、<literal>.catch</literal> の前に <literal>.then</literal> を入れて、
<literal>.then</literal> が呼ばれたらテストを失敗にしたいと考えるかもしれません。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">function failTest() { <co xml:id="CO11-1"/>
    throw new Error("Expected promise to be rejected but it was fulfilled");
}
function mayBeRejected(){
    return Promise.resolve();
}
it("should bad pattern", function () {
    return mayBeRejected().then(failTest).catch(function (error) {
        assert(error.message === "woo");
    });
});</programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para>throwすることでテストを失敗にしたい</para>
</callout>
</calloutlist>
<simpara>しかし、この書き方だと<link linkend="then-or-catch">then or catch?</link>で紹介したように、
<literal>failTest</literal> で投げられたエラーが <literal>catch</literal> されてしまいます。</simpara>
<figure>
<title>Then Catch flow</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/then_catch.png"/>
</imageobject>
<textobject><phrase>Then Catch flow</phrase></textobject>
</mediaobject>
</figure>
<simpara><literal>then</literal> &#8594; <literal>catch</literal> となり、<literal>catch</literal> に渡ってくるErrorオブジェクトは <literal>AssertionError</literal> となり、
意図したものとは違うものが渡ってきてしまいます。</simpara>
<simpara>つまり、onRejectedになること<emphasis role="strong">だけ</emphasis>を期待して書かれたテストは、onFulfilledの状態になってしまうと
常にテストがパスしてしまうという問題を持っていることが分かります。</simpara>
</section>
<section xml:id="_両状態を明示して意図しないテストを改善">
<title>両状態を明示して意図しないテストを改善</title>
<simpara><link linkend="mocha-rejected-promise-test">上記のエラーオブジェクトのテスト</link>を書く場合、
どのようにすれば意図せず通ってしまうテストを無くす事が出来るでしょうか?</simpara>
<simpara>一番単純な方法としては、以下のようにそれぞれの状態の場合にどうなるのかをテストコードに書く方法です。</simpara>
<variablelist>
<varlistentry>
<term>FulFilledとなった場合</term>
<listitem>
<simpara>意図した通りテストが失敗する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Rejectedとなった場合</term>
<listitem>
<simpara><literal>assert</literal> でテストを行える</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>つまり、Fulfilled、Rejected 両方の状態について、テストがどうなってほしいかを明示する必要があるわけです。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">function mayBeRejected() {
    return Promise.resolve();
}
it("catch -&gt; then", function () {
    // FulFilledとなった場合はテストは失敗する
    return mayBeRejected().then(failTest, function (error) {
        assert(error.message === "woo");
    });
});</programlisting>
<simpara>このように書くことで、FulFilledとなった場合は失敗するテストコードを書くことができます。</simpara>
<figure>
<title>Promise onRejected test</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch3_Testing/img/promise-test.png"/>
</imageobject>
<textobject><phrase>Promise onRejected test</phrase></textobject>
</mediaobject>
</figure>
<simpara><link linkend="then-or-catch">then or catch?</link>の時は、エラーの見逃しを避けるため、
<literal>.then(onFulfilled, onRejected)</literal> の第二引数ではなく、<literal>then</literal> &#8594; <literal>catch</literal> と分けることを推奨していました。</simpara>
<simpara>しかし、テストの場合はPromiseの強力なエラーハンドリングが逆にテストの邪魔をしてしまいます。
そのため <literal>.then(failTest, onRejected)</literal> と書くことで、どちらの状態になるのかを明示してテストを書くことができました。</simpara>
</section>
<section xml:id="_まとめ_3">
<title>まとめ</title>
<simpara>MochaのPromiseサポートについてと意図しない挙動となる場合について紹介しました。</simpara>
<itemizedlist>
<listitem>
<simpara>通常のコードは <literal>then</literal> &#8594; <literal>catch</literal> と分けた方がよい</simpara>
<itemizedlist>
<listitem>
<simpara>エラーハンドリングのため。<link linkend="then-or-catch">then or catch?</link>を参照</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>テストコードは <literal>then</literal> にまとめた方がよい</simpara>
<itemizedlist>
<listitem>
<simpara>アサーションエラーがテストフレームワークに届くようにするため。</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara><literal>.then(onFulfilled, onRejected)</literal> を使うことで、
promiseオブジェクトがFulfilled、Rejectedどちらの状態になるかを明示してテストする必要があります。</simpara>
<simpara>しかし、Rejectedのテストであることを明示するために、以下のように書くのはあまり直感的ではないと思います。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">promise.then(failTest, function(error){
    // assertでerrorをテストする
});</programlisting>
<simpara>次は、Promiseのテストを手助けするヘルパー関数を定義して、
もう少し分かりやすいテストを書くにはどうするべきかについて見て行きましょう。</simpara>
</section>
</section>
<section xml:id="controllable-tests">
<title>意図したテストを書くには</title>
<simpara>ここでいう意図したテストとは以下のような定義で進めます。</simpara>
<simpara>あるpromiseオブジェクトをテスト対象として</simpara>
<itemizedlist>
<listitem>
<simpara>Fulfilledされることを期待したテストを書いた時</simpara>
<itemizedlist>
<listitem>
<simpara>Rejectedとなった場合は<emphasis role="strong">Fail</emphasis></simpara>
</listitem>
<listitem>
<simpara>assertionの結果が一致しなかった場合は<emphasis role="strong">Fail</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Rejectedされることを期待したテストを書いた時</simpara>
<itemizedlist>
<listitem>
<simpara>Fulfilledとなった場合は<emphasis role="strong">Fail</emphasis></simpara>
</listitem>
<listitem>
<simpara>assertionの結果が一致しなかった場合は<emphasis role="strong">Fail</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>上記のケース(Fail)に該当しなければテストがパスするという事ですね。</simpara>
<simpara>つまり、ひとつのテストケースにおいて以下のことを書く必要があります。</simpara>
<itemizedlist>
<listitem>
<simpara>Fulfilled or Rejected どちらを期待するか</simpara>
</listitem>
<listitem>
<simpara>assertionで渡された値のチェック</simpara>
</listitem>
</itemizedlist>
<simpara>先ほどの <literal>.then</literal> を使ったコードはRejectedを期待したテストとなっていますね。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">promise.then(failTest, function(error){
    // assertでerrorをテストする
    assert(error instanceof Error);
});</programlisting>
<section xml:id="_どちらの状態になるかを明示する">
<title>どちらの状態になるかを明示する</title>
<simpara>意図したテストにするためには、<link linkend="promise-states">promiseの状態</link>が
Fulfilled or Rejected どちらの状態になって欲しいかを明示する必要があります。</simpara>
<simpara>しかし、<literal>.then</literal> だと引数は省略可能なので、テストが落ちる条件を入れ忘れる可能性もあります。</simpara>
<simpara>そこで、promiseオブジェクトに期待する状態を明示できるヘルパー関数を定義してみましょう。</simpara>
<note>
<simpara>ライブラリ化したものが <link xl:href="https://github.com/azu/promise-test-helper">azu/promise-test-helper</link> にありますが、
今回はその場で簡単に定義して進めます。</simpara>
</note>
<simpara>まずは、先ほどの <literal>.then</literal> の例を元にonRejectedを期待してテスト出来る
<literal>shouldRejected</literal> というヘルパー関数を作ってみたいと思います。</simpara>
<formalpara xml:id="shouldRejected-test.js">
<title>shouldRejected-test.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var assert = require('assert');
function shouldRejected(promise) {
    return {
        'catch': function (fn) {
            return promise.then(function () {
                throw new Error('Expected promise to be rejected but it was fulfilled');
            }, function (reason) {
                fn.call(promise, reason);
            });
        }
    };
}
it('should be rejected', function () {
    var promise = Promise.reject(new Error('human error'));
    return shouldRejected(promise).catch(function (error) {
        assert(error.message === 'human error');
    });
});</programlisting>
</para>
</formalpara>
<simpara><literal>shouldRejected</literal> にpromiseオブジェクトを渡すと、<literal>catch</literal> というメソッドをもつオブジェクトを返します。</simpara>
<simpara>この <literal>catch</literal> にはonRejectedで書くものと全く同じ使い方ができるので、
<literal>catch</literal> の中にassertionによるテストを書けるようになっています。</simpara>
<simpara><literal>shouldRejected</literal> で囲む以外は、通常のpromiseの処理と似た感じになるので以下のようになります。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>shouldRejected</literal> にテスト対象のpromiseオブジェクトを渡す</simpara>
</listitem>
<listitem>
<simpara>返ってきたオブジェクトの <literal>catch</literal> メソッドでonRejectedの処理を書く</simpara>
</listitem>
<listitem>
<simpara>onRejectedにassertionによるテストを書く</simpara>
</listitem>
</orderedlist>
<simpara><literal>shouldRejected</literal> を使った場合、Fulfilledが呼ばれるとエラーをthrowしてテストが失敗するようになっています。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">promise.then(failTest, function(error){
    assert(error.message === 'human error');
});
// == ほぼ同様の意味
shouldRejected(promise).catch(function (error) {
    assert(error.message === 'human error');
});</programlisting>
<simpara><literal>shouldRejected</literal> のようなヘルパー関数を使うことで、テストコードが少し直感的になりましたね。</simpara>
<figure>
<title>Promise onRejected test</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch3_Testing/img/promise-test.png"/>
</imageobject>
<textobject><phrase>Promise onRejected test</phrase></textobject>
</mediaobject>
</figure>
<simpara>同様に、promiseオブジェクトがFulfilledになることを期待する <literal>shouldFulfilled</literal> も書いてみましょう。</simpara>
<formalpara xml:id="shouldFulfilled-test.js">
<title>shouldFulfilled-test.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var assert = require('assert');
function shouldFulfilled(promise) {
    return {
        'then': function (fn) {
            return promise.then(function (value) {
                fn.call(promise, value);
            }, function (reason) {
                throw reason;
            });
        }
    };
}
it('should be fulfilled', function () {
    var promise = Promise.resolve('value');
    return shouldFulfilled(promise).then(function (value) {
        assert(value === 'value');
    });
});</programlisting>
</para>
</formalpara>
<simpara><xref linkend="shouldRejected-test.js"/>と基本は同じで、返すオブジェクトの <literal>catch</literal> が <literal>then</literal> になって中身が逆転しただけですね。</simpara>
</section>
<section xml:id="_まとめ_4">
<title>まとめ</title>
<simpara>Promiseで意図したテストを書くためにはどうするか、またそれを補助するヘルパー関数について学びました。</simpara>
<note>
<simpara>今回書いた <literal>shouldFulfilled</literal> と <literal>shouldRejected</literal> はライブラリとして利用できるようになっています。</simpara>
<simpara><link xl:href="https://github.com/azu/promise-test-helper">azu/promise-test-helper</link> からダウンロードすることが出来ます。</simpara>
</note>
<simpara>また、今回のヘルパー関数は<link linkend="mocha-promise">MochaのPromiseサポート</link>を前提とした書き方なので、
<link linkend="done-promise-test"><literal>done</literal> を使ったテスト</link>では利用しにくいと思います。</simpara>
<simpara>テストフレームワークのPromiseサポートを使うか、<literal>done</literal> のようにコールバックスタイルのテストを使うかは、
人それぞれのスタイルの問題であるためそこまではっきりした優劣はないと思います。</simpara>
<simpara>例えば、 <link xl:href="http://coffeescript.org/">CoffeeScript</link>でテストを書いたりすると、
CoffeeScriptには暗黙のreturnがあるので、<literal>done</literal> を使ったほうが分かりやすいかもしれません。</simpara>
<simpara>Promiseのテストは普通に非同期関数のテスト以上に落とし穴があるため、
どのスタイルを取るかは自由ですが、一貫性を持った書き方をすることが大切だと言えます。</simpara>
</section>
</section>
</section>
<section xml:id="chapter4-advanced-promise">
<title>Chapter.4 - Advanced</title>
<simpara>この章では、これまでに学んだことの応用や発展した内容について学んでいきます。</simpara>
<section xml:id="promise-library">
<title>Promiseのライブラリ</title>
<simpara>このセクションでは、ブラウザが実装しているPromiseではなく、サードパーティにより作られた
Promise互換のライブラリについて紹介していきたいと思います。</simpara>
<section xml:id="_なぜライブラリが必要か">
<title>なぜライブラリが必要か?</title>
<simpara>なぜライブラリが必要か?という疑問に関する多くの答えとしては、
その実行環境で「<link linkend="es6-promises">ES6 Promises</link>が実装されていないから」というのがまず出てくるでしょう。</simpara>
<simpara>Promiseのライブラリを探すときに、一つ目印になる言葉として<link linkend="promises-aplus">Promises/A+互換</link>があります。</simpara>
<simpara><link linkend="promises-aplus">Promises/A+</link>というのは<link linkend="es6-promises">ES6 Promises</link>の前身となったもので、
Promiseの <literal>then</literal> について取り決めたコミュニティベースの仕様です。</simpara>
<simpara>Promises/A+互換と書かれていた場合は <literal>then</literal> についての動作は互換性があり、
多くの場合はそれに加えて <literal>Promise.all</literal> や <literal>catch</literal> 等と同様の機能が実装されています。</simpara>
<simpara>しかし、Promises/A+は <literal>Promise#then</literal> についてのみの仕様となっているため、
他の機能は実装されていても名前が異なる場合があります。</simpara>
<simpara>また、<literal>then</literal> というメソッドに互換性があるという事は、<link linkend="Thenable">Thenable</link>であるということなので、
<link linkend="Promise.resolve">Promise.resolve</link>を使い、ES6のPromiseで定められたpromiseオブジェクトに変換することが出来ます。</simpara>
<note>
<simpara>ES6のPromiseで定められたpromiseオブジェクトというのは、
<literal>catch</literal> というメソッドが使えたり、<literal>Promise.all</literal> で扱う際に問題が起こらないということです。</simpara>
</note>
</section>
<section xml:id="_polyfillとライブラリ">
<title>Polyfillとライブラリ</title>
<simpara>ここでは、大きくわけて2種類のライブラリを紹介したいと思います。</simpara>
<simpara>一つはPolyfillと呼ばれる種類のライブラリで、
もう一つは、<link linkend="promises-aplus">Promises/A+互換</link>に加えて、独自の拡張をもったライブラリです。</simpara>
<note>
<simpara>Promiseのライブラリは星の数ほどあるので、ここで紹介するのは極々一部です。</simpara>
</note>
<section xml:id="promise-polyfill">
<title>Polyfill</title>
<simpara>Polyfillライブラリは読み込む事で、IE10等まだPromiseが実装されていないブラウザ等でも、
Promiseと同等の機能を同じメソッド名で提供してくれるライブラリのことです。</simpara>
<simpara>つまり、Polyfillを読みこめばこの書籍で紹介しているコードは、
Promiseがサポートされてない環境でも実行出来るようになります。</simpara>
<variablelist>
<varlistentry>
<term><link xl:href="https://github.com/jakearchibald/es6-promise">jakearchibald/es6-promise</link></term>
<listitem>
<simpara>ES6 Promisesと互換性を持ったPolyfillライブラリです。
<link xl:href="https://github.com/tildeio/rsvp.js">RSVP.js</link> という Promises/A+互換ライブラリがベースとなっており、
これのサブセットとしてES6 PromisesのAPIだけが実装されているライブラリです。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="https://github.com/getify/native-promise-only/">getify/native-promise-only</link></term>
<listitem>
<simpara>ES6 Promisesのpolyfillとなることを目的としたライブラリです。
ES6 Promisesの仕様に厳密に沿うように作られており、仕様にない機能は入れないようになっています。
実行環境にネイティブのPromiseがある場合はそちらを優先します。
この書籍ではこのPolyfillを読み込み、サンプルコードを動かしています</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="https://github.com/yahoo/ypromise">yahoo/ypromise</link></term>
<listitem>
<simpara><link xl:href="http://yuilibrary.com/">YUI</link> の一部としても利用されているES6 Promisesと互換性を持ったPolyfillライブラリです。</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_promise拡張ライブラリ">
<title>Promise拡張ライブラリ</title>
<simpara>Promiseを仕様どおりに実装したものに加えて独自のメソッド等を提供してくれるライブラリです。</simpara>
<simpara>Promise拡張ライブラリは本当に沢山ありますが、以下の2つの著名なライブラリを紹介します。</simpara>
<variablelist>
<varlistentry>
<term><link xl:href="https://github.com/kriskowal/q">kriskowal/q</link></term>
<listitem>
<simpara><literal>Q</literal> と呼ばれるPromisesやDeferredsを実装したライブラリです。
2009年から開発されており、Node.js向けのファイルIOのAPIを提供する <link xl:href="https://github.com/kriskowal/q-io">Q-IO</link> 等、
多くの状況で使える機能が用意されているライブラリです。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="https://github.com/petkaantonov/bluebird">petkaantonov/bluebird</link></term>
<listitem>
<simpara>Promise互換に加えて、キャンセル出来るPromiseや進行度を取得出来るPromise、エラーハンドリングの拡張検出等、
多くの拡張を持っており、またパフォーマンスにも気を配った実装がされているライブラリです。</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Q と Bluebird どちらのライブラリもブラウザでも動作する他、APIリファレンスが充実しているのも特徴的です。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/kriskowal/q/wiki/API-Reference">API Reference · kriskowal/q Wiki</link></simpara>
</listitem>
</itemizedlist>
<simpara>QのドキュメントにはjQueryが持つDeferredの仕組みとどのように違うのか、移行する場合の対応メソッドについても
<link xl:href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">Coming from jQuery</link> にまとめられています。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/petkaantonov/bluebird/blob/master/API.md">bluebird/API.md at master · petkaantonov/bluebird</link></simpara>
</listitem>
</itemizedlist>
<simpara>BluebirdではPromiseを使った豊富な実装例に加えて、エラーが起きた時の対処法や
<link xl:href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns">Promiseのアンチパターン</link> について書かれています。</simpara>
<simpara>どちらのドキュメントも優れているため、このライブラリを使ってない場合でも読んでおくと参考になる事が多いと思います。</simpara>
</section>
</section>
<section xml:id="_まとめ_5">
<title>まとめ</title>
<simpara>このセクションではPromiseのライブラリとしてPolyfillと拡張ライブラリを紹介しました。</simpara>
<simpara>Promiseのライブラリは多種多様であるため、どれを使用するかは好みの問題といえるでしょう。</simpara>
<simpara>しかし、PromiseはPromises/A+ または ES6 Promisesという共通のインターフェースを持っているため、
そのライブラリで書かれているコードや独自の拡張などは、他のライブラリを利用している時でも参考になるケースは多いでしょう。</simpara>
<simpara>そのようなPromiseの共通の概念を学び、応用できるようになるのがこの書籍の目的の一つです。</simpara>
</section>
</section>
<section xml:id="resolve-thenable">
<title>Promise.resolveとThenable</title>
<simpara><link linkend="ch2-promise-resolve">第二章のPromise.resolve</link>にて、<literal>Promise.resolve</literal> の大きな特徴の一つとしてthenableなオブジェクトを変換する機能について紹介しました。</simpara>
<simpara>このセクションでは、thenableなオブジェクトからpromiseオブジェクトに変換してどのように利用するかについて学びたいと思います。</simpara>
<section xml:id="_web_notificationsをthenableにする">
<title>Web Notificationsをthenableにする</title>
<simpara><link xl:href="https://developer.mozilla.org/ja/docs/Web/API/notification">Web Notifications</link>という
デスクトップ通知を行うAPIを例に考えてみます。</simpara>
<simpara>Web Notifications APIについて詳しくは以下を参照して下さい。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://developer.mozilla.org/ja/docs/WebAPI/Using_Web_Notifications">Web Notifications の使用 - WebAPI | MDN</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://caniuse.com/notifications">Can I use Web Notifications</link></simpara>
</listitem>
</itemizedlist>
<simpara>Web Notifications APIについて簡単に解説すると、以下のように <literal>new Notification</literal> をすることで通知メッセージが表示できます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">new Notification("Hi!");</programlisting>
<simpara>しかし、通知を行うためには、<literal>new Notification</literal> をする前にユーザーに許可を取る必要があります。</simpara>
<figure>
<title>Notificationの許可ダイアログ</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch4_AdvancedPromises/img/notification-dialog.png"/>
</imageobject>
<textobject><phrase>Notificationの許可ダイアログ</phrase></textobject>
</mediaobject>
</figure>
<simpara>この許可ダイアログで選択した結果は、<literal>Notification.permission</literal> に入りますが、
値は許可("granted")か不許可("denied")の2種類です。</simpara>
<note>
<simpara>Notificationのダイアログの選択肢は、
Firefoxだと許可、不許可に加えて <emphasis>永続</emphasis> か <emphasis>セッション限り</emphasis> の組み合わせがありますが、値自体は同じです。</simpara>
</note>
<simpara>許可ダイアログは <literal>Notification.requestPermission()</literal> を実行すると表示され、
ユーザーが選択した結果がコールバック関数の <literal>status</literal> に渡されます。</simpara>
<simpara>コールバックを受け付けることから分かるように、この許可、不許可は非同期的に行われます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">Notification.requestPermission(function (status) {
    // statusに"granted" or "denied"が入る
    console.log(status);
});</programlisting>
<simpara>通知を行うまでの流れをまとめると以下のようになります。</simpara>
<itemizedlist>
<listitem>
<simpara>ユーザーに通知の許可を受け付ける非同期処理がある</simpara>
</listitem>
<listitem>
<simpara>許可がある場合は <literal>new Notification</literal> で通知を表示できる</simpara>
<itemizedlist>
<listitem>
<simpara>既に許可済みのケース</simpara>
</listitem>
<listitem>
<simpara>その場で許可を貰うケース</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>許可がない場合は何もしない</simpara>
</listitem>
</itemizedlist>
<simpara>いくつかのパターンが出ますが、最終的には許可か不許可になるので、以下の2パターンにまとめることが出来ます。</simpara>
<variablelist>
<varlistentry>
<term>許可時("granted")</term>
<listitem>
<simpara><literal>new Notification</literal> で通知を作成</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>不許可時("denied")</term>
<listitem>
<simpara>何もしない</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>この2パターンはどこかで見たことがありますね。
そう、PromiseのFulfilled または Rejected となった時の動作で書くことが出来そうな気がします。</simpara>
<variablelist>
<varlistentry>
<term>resolve(成功)した時 == 許可時("granted")</term>
<listitem>
<simpara><literal>onFulfilled</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>reject(失敗)した時 == 不許可時("denied")</term>
<listitem>
<simpara><literal>onRejected</literal>  が呼ばれる</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Promiseで書けそうな目処が見えた所で、まずはコールバックスタイルで書いてみましょう。</simpara>
</section>
<section xml:id="_web_notification_ラッパー">
<title>Web Notification ラッパー</title>
<simpara>まずは先ほどのWeb Notification APIのラッパー関数をコールバックスタイルで書くと次のように書くことが出来ます。</simpara>
<formalpara xml:id="notification-callback.js" role="executable">
<title>notification-callback.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function notifyMessage(message, options, callback) {
    if (typeof Notification === 'undefined') {
        callback(new Error('doesn\'t support Notification API'));
        return;
    }
    if (Notification.permission === 'granted') {
        var notification = new Notification(message, options);
        callback(null, notification);
    } else {
        Notification.requestPermission(function (status) {
            if (Notification.permission !== status) {
                Notification.permission = status;
            }
            if (status === 'granted') {
                var notification = new Notification(message, options);
                callback(null, notification);
            } else {
                callback(new Error('user denied'));
            }
        });
    }
}
// 実行例
// 第二引数は `Notification` に渡すオプションオブジェクト
notifyMessage("Hi!", {}, function (error, notification) {
    if(error){
        console.error(error);
        return;
    }
    console.log(notification);// 通知のオブジェクト
});</programlisting>
</para>
</formalpara>
<simpara>コールバックスタイルでは、許可がない場合は <literal>error</literal> に値が入り、
許可がある場合は通知が行われて <literal>notification</literal> に値が入ってくるという感じにしました。</simpara>
<formalpara>
<title>コールバック関数はエラーとnotificationオブジェクトを受け取る</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function callback(error, notification){

}</programlisting>
</para>
</formalpara>
<simpara>次に、このコールバックスタイルの関数をPromiseとして使える関数を書いてみたいと思います。</simpara>
</section>
<section xml:id="_web_notification_as_promise">
<title>Web Notification as Promise</title>
<simpara>先ほどのコールバックスタイルの <literal>notifyMessage</literal> とは別に、
promiseオブジェクトを返す <literal>notifyMessageAsPromise</literal> を定義してみます。</simpara>
<formalpara xml:id="notification-as-promise.js" role="executable">
<title>notification-as-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function notifyMessage(message, options, callback) {
    if (typeof Notification === 'undefined') {
        callback(new Error('doesn\'t support Notification API'));
        return;
    }
    if (Notification.permission === 'granted') {
        var notification = new Notification(message, options);
        callback(null, notification);
    } else {
        Notification.requestPermission(function (status) {
            if (Notification.permission !== status) {
                Notification.permission = status;
            }
            if (status === 'granted') {
                var notification = new Notification(message, options);
                callback(null, notification);
            } else {
                callback(new Error('user denied'));
            }
        });
    }
}
function notifyMessageAsPromise(message, options) {
    return new Promise(function (resolve, reject) {
        notifyMessage(message, options, function (error, notification) {
            if (error) {
                reject(error);
            } else {
                resolve(notification);
            }
        });
    });
}
// 実行例
notifyMessageAsPromise("Hi!").then(function (notification) {
    console.log(notification);// 通知のオブジェクト
}).catch(function(error){
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>上記の実行例では、許可がある場合 <literal>"Hi!"</literal> という通知が表示されます。</simpara>
<simpara>許可されている場合は <literal>.then</literal> が呼ばれ、
不許可となった場合は <literal>.catch</literal> が呼ばれます。</simpara>
<note>
<simpara>ブラウザはWeb Notifications APIの状態をサイトごとに許可状態を記憶できるため、
実際には以下の4つのパターンが存在します。</simpara>
<variablelist>
<varlistentry>
<term>既に許可されている</term>
<listitem>
<simpara><literal>.then</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>許可ダイアログがでて許可された</term>
<listitem>
<simpara><literal>.then</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>既に不許可となっている</term>
<listitem>
<simpara><literal>.catch</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>許可ダイアログが出て不許可となった</term>
<listitem>
<simpara><literal>.catch</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>つまり、Web Notifications APIをそのまま扱うと、4つのパターンについて書かないといけませんが、
それを2パターンにできるラッパーを書くと扱いやすくなります。</simpara>
</note>
<simpara>上記の<xref linkend="notification-as-promise.js"/>は、とても便利そうですが実際に使うときには
<emphasis role="strong">Promiseをサポートしてない環境では使えない</emphasis>という問題があります。</simpara>
<simpara><xref linkend="notification-as-promise.js"/>のようなPromiseスタイルで使えるライブラリを作る場合、
ライブラリ作成者には以下の選択肢があると思います。</simpara>
<variablelist xml:id="promise-library-choice">
<varlistentry>
<term>Promiseが使える環境を前提とする</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>利用者に <literal>Promise</literal> があることを保証してもらう</simpara>
</listitem>
<listitem>
<simpara>Promiseをサポートしてない環境では動かないことにする</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>ライブラリ自体に <literal>Promise</literal> の実装を入れてしまう</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>ライブラリ自体にPromiseの実装を取り込む</simpara>
</listitem>
<listitem>
<simpara>例) <link xl:href="https://github.com/mozilla/localForage">localForage</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>コールバックでも <literal>Promise</literal> でも使えるようにする</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>利用者がどちらを使うかを選択出来るようにする</simpara>
</listitem>
<listitem>
<simpara>Thenableを返せるようにする</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<simpara><xref linkend="notification-as-promise.js"/>は <literal>Promise</literal> があることを前提としたような書き方です。</simpara>
<simpara>本題に戻り<link linkend="Thenable">Thenable</link>はここでいう<emphasis role="strong">コールバックでも <literal>Promise</literal> でも使えるようにする</emphasis>という事を
実現するのに役立つ概念です。</simpara>
</section>
<section xml:id="_web_notifications_as_thenable">
<title>Web Notifications As Thenable</title>
<simpara><link linkend="Thenable">thenable</link>というのは <literal>.then</literal> というメソッドを持ってるオブジェクトのことを言いましたね。
次は<xref linkend="notification-callback.js"/>に <literal>thenable</literal> を返すメソッドを追加してみましょう。</simpara>
<formalpara xml:id="notification-thenable.js" role="executable">
<title>notification-thenable.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function notifyMessage(message, options, callback) {
    if (typeof Notification === 'undefined') {
        callback(new Error('doesn\'t support Notification API'));
        return;
    }
    if (Notification.permission === 'granted') {
        var notification = new Notification(message, options);
        callback(null, notification);
    } else {
        Notification.requestPermission(function (status) {
            if (Notification.permission !== status) {
                Notification.permission = status;
            }
            if (status === 'granted') {
                var notification = new Notification(message, options);
                callback(null, notification);
            } else {
                callback(new Error('user denied'));
            }
        });
    }
}
// `thenable` を返す
function notifyMessageAsThenable(message, options) {
    return {
        'then': function (resolve, reject) {
            notifyMessage(message, options, function (error, notification) {
                if (error) {
                    reject(error);
                } else {
                    resolve(notification);
                }
            });
        }
    };
}
// 実行例
Promise.resolve(notifyMessageAsThenable("message")).then(function (notification) {
    console.log(notification);// 通知のオブジェクト
}).catch(function(error){
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><xref linkend="notification-thenable.js"/> には <literal>notifyMessageAsThenable</literal> というそのままのメソッドを追加してみました。
返すオブジェクトには <literal>then</literal> というメソッドがあります。</simpara>
<simpara><literal>then</literal> メソッドの仮引数には <literal>new Promise(function (resolve, reject){})</literal> と同じように、
解決した時に呼ぶ <literal>resolve</literal> と、棄却した時に呼ぶ <literal>reject</literal> が渡ります。</simpara>
<simpara><literal>then</literal> メソッドがやっている中身は<xref linkend="notification-as-promise.js"/>の <literal>notifyMessageAsPromise</literal> と同じですね。</simpara>
<simpara>この <literal>thenable</literal> を <literal>Promise.resolve(thenable)</literal> を使いpromiseオブジェクトにしてから、
Promiseとして利用していることが分かりますね。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">Promise.resolve(notifyMessageAsThenable("message")).then(function (notification) {
    console.log(notification);// 通知のオブジェクト
}).catch(function(error){
    console.error(error);
});</programlisting>
<simpara>Thenableを使った<xref linkend="notification-thenable.js"/>とPromiseに依存した<xref linkend="notification-as-promise.js"/>は、
非常に似た使い方ができることがわかります。</simpara>
<simpara><xref linkend="notification-thenable.js"/>には<xref linkend="notification-as-promise.js"/>と比べた時に、次のような違いがあります。</simpara>
<itemizedlist>
<listitem>
<simpara>ライブラリ側に <literal>Promise</literal> 実装そのものはでてこない</simpara>
<itemizedlist>
<listitem>
<simpara>利用者が <literal>Promise.resolve(thenable)</literal> を使い <literal>Promise</literal> の実装を与える</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Promiseとして使う時に <literal>Promise.resolve(thenable)</literal> と一枚挟む必要がある</simpara>
</listitem>
</itemizedlist>
<simpara><link linkend="Thenable">Thenable</link>オブジェクトを利用することで、
既存のコールバックスタイルとPromiseスタイルの中間的な実装をすることができました。</simpara>
</section>
<section xml:id="_まとめ_6">
<title>まとめ</title>
<simpara>このセクションではThenableとは何かやThenableを <literal>Promise.resolve(thenable)</literal> を使って、
promiseオブジェクトとして利用する方法について学びました。</simpara>
<simpara>Callback&#8201;&#8212;&#8201;Thenable&#8201;&#8212;&#8201;Promise</simpara>
<simpara>Thenableスタイルは、コールバックスタイルとPromiseスタイルの中間的な表現で、
ライブラリが公開するAPIとしては中途半端なためあまり見かけることがないと思います。</simpara>
<simpara>Thenable自体は <literal>Promise</literal> という機能に依存してはいませんが、Promise以外からの利用方法は特にないため、
間接的にはPromiseに依存しています。</simpara>
<simpara>また、使うためには利用者が <literal>Promise.resolve(thenable)</literal> について理解している必要があるため、
ライブラリの公開APIとしては難しい部分があります。
Thenable自体は公開APIより、内部的に使われてるケースが多いでしょう。</simpara>
<note>
<simpara>非同期処理を行うライブラリを書く際には、まずはコールバックスタイルの関数を書いて公開APIとすることをオススメします。</simpara>
<simpara>Node.jsのCore moduleがこの方法をとっているように、ライブラリが提供するのは基本となるコールバックスタイル関数としたほうが、
利用者がPromiseやGenerator等の好きな方法で実装ができるためです。</simpara>
<simpara>最初からPromiseで利用することを目的としたライブラリや、その機能がPromiseに依存している場合は、
promiseオブジェクトを返す関数を公開APIとしても問題ないと思います。</simpara>
</note>
<section xml:id="_thenableの使われているところ">
<title>Thenableの使われているところ</title>
<simpara>では、どのような場面でThenableは使われてるのでしょうか?</simpara>
<simpara>恐らく、一番多く使われている所は<link linkend="promise-library">Promiseのライブラリ</link>間での相互変換でしょう。</simpara>
<simpara>例えば、 QライブラリのPromiseのインスタンスであるQ promiseオブジェクトは、
<link linkend="es6-promises">ES6 Promises</link>のpromiseオブジェクトが持っていないメソッドを持っています。
Q promiseオブジェクトには <literal>promise.finally(callback)</literal> や <literal>promise.nodeify(callback)</literal> などのメソッドが用意されてます。</simpara>
<simpara>ES6 PromisesのpromiseオブジェクトをQ promiseオブジェクトに変換するときに使われるのが、
まさにこのThenableです。</simpara>
<formalpara>
<title>thenableを使ってQ promiseオブジェクトにする</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var Q = require("Q");
// このpromiseオブジェクトはES6のもの
var promise = new Promise(function(resolve){
    resolve(1);
});
// Q promiseオブジェクトに変換する
Q(promise).then(function(value){
    console.log(value);
}).finally(function(){ <co xml:id="CO12-1"/>
    console.log("finally");
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO12-1">
<para>Q promiseオブジェクトとなったため <literal>finally</literal> が利用できる</para>
</callout>
</calloutlist>
<simpara>最初に作成したpromiseオブジェクトは <literal>then</literal> というメソッドを持っているので、もちろんThenableです。
<literal>Q(thenable)</literal> とすることでThenableなオブジェクトをQ promiseオブジェクトへと変換することが出来ます。</simpara>
<simpara>これは、<literal>Promise.resolve(thenable)</literal> と同じ仕組みといえるので、もちろん逆も可能です。</simpara>
<simpara>このように、Promiseライブラリはそれぞれ独自に拡張したpromiseオブジェクトを持っていますが、
Thenableという共通の概念を使うことでライブラリ間(もちろんネイティブPromiseも含めて)で相互にpromiseオブジェクトを変換することが出来ます。</simpara>
<simpara>このようにThenableが使われる所の多くはライブラリ内部の実装であるため、あまり目にする機会はないかもしれません。
しかしこのThenableはPromiseでも大事な概念であるため知っておくとよいでしょう。</simpara>
</section>
</section>
</section>
<section xml:id="not-throw-use-reject">
<title>throwしないで、rejectしよう</title>
<simpara>Promiseコンストラクタや、<literal>then</literal> で実行される関数は基本的に、
<literal>try&#8230;&#8203;catch</literal> で囲まれてるような状態なので、その中で <literal>throw</literal> してもプログラムは終了しません。</simpara>
<simpara>Promiseの中で <literal>throw</literal> による例外が発生した場合は自動的に <literal>try&#8230;&#8203;catch</literal> され、そのpromiseオブジェクトはRejectedとなります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">var promise = new Promise(function(resolve, reject){
    throw new Error("message");
});
promise.catch(function(error){
    console.error(error);// =&gt; "message"
});</programlisting>
<simpara>このように書いても動作的には問題ありませんが、<link linkend="promise-states">promiseオブジェクトの状態</link>をRejectedにしたい場合は
<literal>reject</literal> という与えられた関数を呼び出すのが一般的です。</simpara>
<simpara>先ほどのコードは以下のように書くことが出来ます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">var promise = new Promise(function(resolve, reject){
    reject(new Error("message"));
});
promise.catch(function(error){
    console.error(error);// =&gt; "message"
})</programlisting>
<simpara><literal>throw</literal> が <literal>reject</literal> に変わったと考えれば、<literal>reject</literal> にはErrorオブジェクトを渡すべきであるということが分かりやすいかもしれません。</simpara>
<section xml:id="_なぜrejectした方がいいのか">
<title>なぜrejectした方がいいのか</title>
<simpara>そもそも、promiseオブジェクトの状態をRejectedにしたい場合に、
何故 <literal>throw</literal> ではなく <literal>reject</literal> した方がいいのでしょうか?</simpara>
<simpara>ひとつは <literal>throw</literal> が意図したものか、それとも本当に<emphasis role="strong">例外</emphasis>なのか区別が難しくなってしまうことにあります。</simpara>
<simpara>例えば、Chrome等の開発者ツールには例外が発生した時に、
デバッガーが自動でbreakする機能が用意されています。</simpara>
<figure>
<title>Pause On Caught Exceptions</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch4_AdvancedPromises/img/chrome_on_caught_exception.png"/>
</imageobject>
<textobject><phrase>Pause On Caught Exceptions</phrase></textobject>
</mediaobject>
</figure>
<simpara>この機能を有効にしていた場合、以下のように <literal>throw</literal> するとbreakしてしまいます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var promise = new Promise(function(resolve, reject){
    throw new Error("message");
});</programlisting>
<simpara>本来デバッグとは関係ない場所でbreakしてしまうため、
Promiseの中で <literal>throw</literal> している箇所があると、この機能が殆ど使い物にならなくなってしまうでしょう。</simpara>
</section>
<section xml:id="_thenでもrejectする">
<title>thenでもrejectする</title>
<simpara>Promiseコンストラクタの中では <literal>reject</literal> という関数そのものがあるので、
<literal>throw</literal> を使わないでpromiseオブジェクトをRejectedにするのは簡単でした。</simpara>
<simpara>では、次のような <literal>then</literal> の中でrejectしたい場合はどうすればいいでしょうか?</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var promise = Promise.resolve();
promise.then(function (value) {
    setTimeout(function () {
        // 一定時間経って終わらなかったらrejectしたい - 2
    }, 1000);
    // 時間がかかる処理 - 1
    somethingHardWork();
}).catch(function (error) {
    // タイムアウトエラー - 3
});</programlisting>
<simpara>いわゆるタイムアウト処理ですが、<literal>then</literal> の中で <literal>reject</literal> を呼びたいと思った場合に、
コールバック関数に渡ってくるのは一つ前のpromiseオブジェクトの返した値だけなので困ってしまいます。</simpara>
<note>
<simpara>Promiseを使ったタイムアウト処理の実装については <link linkend="race-delay-timeout">Promise.raceとdelayによるXHRのキャンセル</link> にて詳しく解説しています。</simpara>
</note>
<simpara>ここで少し <literal>then</literal> の挙動について思い出してみましょう。</simpara>
<simpara><literal>then</literal> に登録するコールバック関数では値を <literal>return</literal> することができます。
この時returnした値が、次の <literal>then</literal> や <literal>catch</literal> のコールバックに渡されます。</simpara>
<simpara>また、returnするものはプリミティブな値に限らずオブジェクト、そしてpromiseオブジェクトも返す事が出来ます。</simpara>
<simpara>この時、returnしたものがpromiseオブジェクトである場合、そのpromiseオブジェクトの状態によって、
次の <literal>then</literal> に登録されたonFulfilledとonRejectedのうち、どちらが呼ばれるかを決めることが出来ます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var promise = Promise.resolve();
promise.then(function () {
    var retPromise = new Promise(function (resolve, reject) {
        // resolve or reject で onFulfilled or onRejected どちらを呼ぶか決まる
    });
    return retPromise;<co xml:id="CO13-1"/>
}).then(onFulfilled, onRejected);</programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>次に呼び出されるthenのコールバックはpromiseオブジェクトの状態によって決定される</para>
</callout>
</calloutlist>
<simpara>つまり、この <literal>retPromise</literal> がRejectedになった場合は、<literal>onRejected</literal> が呼び出されるので、
<literal>throw</literal> を使わなくても <literal>then</literal> の中でrejectすることが出来ます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">var onRejected = console.error.bind(console);
var promise = Promise.resolve();
promise.then(function () {
    var retPromise = new Promise(function (resolve, reject) {
       reject(new Error("this promise is rejected"));
    });
    return retPromise;
}).catch(onRejected);</programlisting>
<simpara>これは、<xref linkend="Promise.reject"/> を使うことでもっと簡潔に書くことが出来ます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">var onRejected = console.error.bind(console);
var promise = Promise.resolve();
promise.then(function () {
    return Promise.reject(new Error("this promise is rejected"));
}).catch(onRejected);</programlisting>
</section>
<section xml:id="_まとめ_7">
<title>まとめ</title>
<simpara>このセクションでは、以下のことについて学びました。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>throw</literal> ではなくて <literal>reject</literal> した方が安全</simpara>
</listitem>
<listitem>
<simpara><literal>then</literal> の中でも <literal>reject</literal> する方法</simpara>
</listitem>
</itemizedlist>
<simpara>中々使いどころが多くはないかもしれませんが、安易に <literal>throw</literal> してしまうよりはいい事が多いので、
覚えておくといいでしょう。</simpara>
<simpara>これを利用した具体的な例としては、
<link linkend="race-delay-timeout">Promise.raceとdelayによるXHRのキャンセル</link> で解説しています。</simpara>
</section>
</section>
<section xml:id="deferred-and-promise">
<title>DeferredとPromise</title>
<simpara>このセクションではDeferredとPromiseの関係について簡潔に学んでいきます。</simpara>
<section xml:id="_deferredとは何か">
<title>Deferredとは何か</title>
<simpara>Deferredという単語はPromiseと同じコンテキストで聞いた事があるかもしれません。
有名な所だと <link xl:href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</link> や <link xl:href="http://cho45.stfuawsc.com/jsdeferred/">JSDeferred</link> 等があげられるでしょう。</simpara>
<simpara>DeferredはPromiseと違い、共通の仕様があるわけではなく、各ライブラリがそのような目的の実装をそう呼んでいます。</simpara>
<simpara>今回は <link xl:href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</link> のようなDeferredの実装を中心にして話を進めます。</simpara>
</section>
<section xml:id="_deferredとpromiseの関係">
<title>DeferredとPromiseの関係</title>
<simpara>DeferredとPromiseの関係を簡単に書くと以下のようになります。</simpara>
<itemizedlist>
<listitem>
<simpara>Deferred は Promiseを持っている</simpara>
</listitem>
<listitem>
<simpara>Deferred は Promiseの状態を操作する特権的なメソッドを持っている</simpara>
</listitem>
</itemizedlist>
<figure>
<title>DeferredとPromise</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch4_AdvancedPromises/img/deferred-and-promise.png"/>
</imageobject>
<textobject><phrase>DeferredとPromise</phrase></textobject>
</mediaobject>
</figure>
<simpara>この図を見ると分かりますが、DeferredとPromiseは比べるような関係ではなく、
DeferredがPromiseを内蔵しているような関係になっていることが分かります。</simpara>
<note>
<simpara>jQuery.Deferredの構造を簡略化したものです。もちろんPromiseを持たないDeferredの実装もあります。</simpara>
</note>
<simpara>図だけだと分かりにくいので、実際にPromiseを使ってDeferredを実装してみましょう。</simpara>
</section>
<section xml:id="_deferred_top_on_promise">
<title>Deferred top on Promise</title>
<simpara>Promiseの上にDeferredを実装した例です。</simpara>
<formalpara xml:id="deferred.js">
<title>deferred.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function Deferred() {
    this.promise = new Promise(function (resolve, reject) {
        this._resolve = resolve;
        this._reject = reject;
    }.bind(this));
}
Deferred.prototype.resolve = function (value) {
    this._resolve(value);
};
Deferred.prototype.reject = function (reason) {
    this._reject(reason);
};</programlisting>
</para>
</formalpara>
<simpara>以前Promiseを使って実装した<link linkend="xhr-promise.js"><literal>getURL</literal></link>をこのDeferredで実装しなおしてみます。</simpara>
<formalpara xml:id="xhr-deferred.js" role="executable">
<title>xhr-deferred.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function Deferred() {
    this.promise = new Promise(function (resolve, reject) {
        this._resolve = resolve;
        this._reject = reject;
    }.bind(this));
}
Deferred.prototype.resolve = function (value) {
    this._resolve(value);
};
Deferred.prototype.reject = function (reason) {
    this._reject(reason);
};
function getURL(URL) {
    var deferred = new Deferred();
    var req = new XMLHttpRequest();
    req.open('GET', URL, true);
    req.onload = function () {
        if (req.status === 200) {
            deferred.resolve(req.responseText);
        } else {
            deferred.reject(new Error(req.statusText));
        }
    };
    req.onerror = function () {
        deferred.reject(new Error(req.statusText));
    };
    req.send();
    return deferred.promise;
}
// 実行例
var URL = "http://httpbin.org/get";
getURL(URL).then(function onFulfilled(value){
    console.log(value);
}).catch(console.error.bind(console));</programlisting>
</para>
</formalpara>
<simpara>Promiseの状態を操作する特権的なメソッドというのは、
promiseオブジェクトの状態をresolve、rejectすることができるメソッドで、
通常のPromiseだとコンストラクタで渡した関数の中でしか操作する事が出来ません。</simpara>
<simpara>通常のPromiseで実装したものと見比べていきたいと思います。</simpara>
<formalpara role="executable">
<title>xhr-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function getURL(URL) {
    return new Promise(function (resolve, reject) {
        var req = new XMLHttpRequest();
        req.open('GET', URL, true);
        req.onload = function () {
            if (req.status === 200) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = function () {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
// 実行例
var URL = "http://httpbin.org/get";
getURL(URL).then(function onFulfilled(value){
    console.log(value);
}).catch(console.error.bind(console));</programlisting>
</para>
</formalpara>
<simpara>2つの <literal>getURL</literal> を見比べて見ると以下のような違いがある事が分かります。</simpara>
<itemizedlist>
<listitem>
<simpara>Deferred の場合は全体がPromiseで囲まれていない</simpara>
<itemizedlist>
<listitem>
<simpara>関数で囲んでないため、1段ネストが減っている</simpara>
</listitem>
<listitem>
<simpara>Promiseコンストラクタの中で処理が行われていないため、自動的に例外をキャッチしない</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>逆に以下の部分は同じ事をやっています。</simpara>
<itemizedlist>
<listitem>
<simpara>全体的な処理の流れ</simpara>
<itemizedlist>
<listitem>
<simpara><literal>resolve</literal>、<literal>reject</literal> を呼ぶタイミング</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>関数はpromiseオブジェクトを返す</simpara>
</listitem>
</itemizedlist>
<simpara>このDeferredはPromiseを持っているため、大きな流れは同じですが、
Deferredには特権的なメソッドを持っていることや自分で流れを制御する裁量が大きいことが分かります。</simpara>
<simpara>例えば、Promiseの場合はコンストラクタの中に処理を書くことが通例なので、
<literal>resolve</literal>、<literal>reject</literal> を呼ぶタイミングが大体みて分かります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">new Promise(function (resolve, reject){
    // この中に解決する処理を書く
});</programlisting>
<simpara>一方Deferredの場合は、関数的なまとまりはないのでdeferredオブジェクトを作ったところから、
任意のタイミングで <literal>resolve</literal>、<literal>reject</literal> を呼ぶ感じになります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var deferred = new Deferred();

// どこかのタイミングでdeferred.resolve or deferred.rejectを呼ぶ</programlisting>
<simpara>このように小さな<emphasis role="strong">Deferred</emphasis>の実装ですが<emphasis role="strong">Promise</emphasis>との違いが出ていることが分かります。</simpara>
<simpara>これは、Promiseが値を抽象化したオブジェクトなのに対して、
Deferredはまだ処理が終わってないという状態や操作を抽象化したオブジェクトである違いがでているのかもしれません。</simpara>
<simpara>言い換えると、
Promiseはこの値は将来的に正常な値(FulFilled)か異常な値(Rejected)が入るというものを予約したオブジェクトなのに対して、
Deferredはまだ処理が終わってないという事を表すオブジェクトで、
処理が終わった時の結果を取得する機構(Promise)に加えて処理を進める機構をもったものといえるかもしれません。</simpara>
<simpara>より詳しくDeferredについて知りたい人は以下を参照するといいでしょう。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt1-theory-and-semantics">Promise &amp; Deferred objects in JavaScript Pt.1: Theory and Semantics.</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://skitazaki.appspot.com/translation/twisted-intro-ja/index.html">Twisted 入門 — Twisted Intro</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern">Promise anti patterns · petkaantonov/bluebird Wiki</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">Coming from jQuery · kriskowal/q Wiki</link></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>DeferredはPythonの <link xl:href="https://twistedmatrix.com/trac/">Twisted</link> というフレームワークが最初に定義した概念です。
JavaScriptへは <link xl:href="http://mochi.github.io/mochikit/doc/html/MochiKit/Async.html">MochiKit.Async</link> 、 <link xl:href="http://dojotoolkit.org/reference-guide/1.9/dojo/Deferred.html">dojo/Deferred</link> 等のライブラリがその概念を持ってきたと言われています。</simpara>
</note>
</section>
</section>
<section xml:id="race-delay-timeout">
<title>Promise.raceとdelayによるXHRのキャンセル</title>
<simpara>このセクションでは<link linkend="ch2-promise-race">2章</link>で紹介した<link linkend="Promise.race"><literal>Promise.race</literal></link>のユースケースとして、
Promise.raceを使ったタイムアウトの実装を学んでいきます。</simpara>
<simpara>もちろんXHRは <link xl:href="https://developer.mozilla.org/ja/docs/XMLHttpRequest/Synchronous_and_Asynchronous_Requests">timeout</link> プロパティを持っているので、
これを利用すると簡単に出来ますが、複数のXHRを束ねたタイムアウトや他の機能でも応用が効くため、
分かりやすい非同期処理であるXHRにおけるタイムアウトによるキャンセルを例にしています。</simpara>
<section xml:id="_promiseで一定時間待つ">
<title>Promiseで一定時間待つ</title>
<simpara>まずはタイムアウトをPromiseでどう実現するかを見て行きたいと思います。</simpara>
<simpara>タイムアウトというのは一定時間経ったら何かするという処理なので、<literal>setTimeout</literal> を使えばいいことが分かりますね。</simpara>
<simpara>まずは単純に <literal>setTimeout</literal> をPromiseでラップした関数を作ってみましょう。</simpara>
<formalpara xml:id="delayPromise.js">
<title>delayPromise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function delayPromise(ms) {
    return new Promise(function (resolve) {
        setTimeout(resolve, ms);
    });
}</programlisting>
</para>
</formalpara>
<simpara><literal>delayPromise(ms)</literal> は引数で指定したミリ秒後にonFulfilledを呼ぶpromiseオブジェクトを返すので、
通常の <literal>setTimeout</literal> を直接使ったものと比較すると以下のように書けるだけの違いです。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">setTimeout(function () {
    alert("100ms 経ったよ!");
}, 100);
// == ほぼ同様の動作
delayPromise(100).then(function () {
    alert("100ms 経ったよ!");
});</programlisting>
<simpara>ここでは<emphasis role="strong">promiseオブジェクト</emphasis>であるという事が重要になってくるので覚えておいて下さい。</simpara>
</section>
<section xml:id="_promise_raceでタイムアウト">
<title>Promise.raceでタイムアウト</title>
<simpara><literal>Promise.race</literal> について簡単に振り返ると、
以下のようにどれか一つでもpromiseオブジェクトが解決状態になったら次の処理を実行する静的メソッドでした。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var winnerPromise = new Promise(function (resolve) {
        setTimeout(function () {
            console.log('this is winner');
            resolve('this is winner');
        }, 4);
    });
var loserPromise = new Promise(function (resolve) {
        setTimeout(function () {
            console.log('this is loser');
            resolve('this is loser');
        }, 1000);
    });
// 一番最初のものがresolveされた時点で終了
Promise.race([winnerPromise, loserPromise]).then(function (value) {
    console.log(value);    // =&gt; 'this is winner'
});</programlisting>
<simpara>先ほどの<link linkend="delayPromise.js">delayPromise</link>と別のpromiseオブジェクトを、
<literal>Promise.race</literal> によって競争させることで簡単にタイムアウトが実装出来ます。</simpara>
<formalpara xml:id="simple-timeout-promise.js">
<title>simple-timeout-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function delayPromise(ms) {
    return new Promise(function (resolve) {
        setTimeout(resolve, ms);
    });
}
function timeoutPromise(promise, ms) {
    var timeout = delayPromise(ms).then(function () {
            throw new Error('Operation timed out after ' + ms + ' ms');
        });
    return Promise.race([promise, timeout]);
}</programlisting>
</para>
</formalpara>
<simpara><literal>timeoutPromise(比較対象のpromise, ms)</literal> はタイムアウト処理を入れたい
promiseオブジェクトとタイムアウトの時間を受け取り、<literal>Promise.race</literal> により競争させたpromiseオブジェクトを返します。</simpara>
<simpara><literal>timeoutPromise</literal> を使うことで以下のようにタイムアウト処理を書くことが出来るようになります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function delayPromise(ms) {
    return new Promise(function (resolve) {
        setTimeout(resolve, ms);
    });
}
function timeoutPromise(promise, ms) {
    var timeout = delayPromise(ms).then(function () {
            throw new Error('Operation timed out after ' + ms + ' ms');
        });
    return Promise.race([promise, timeout]);
}
// 実行例
var taskPromise = new Promise(function(resolve){
    // 何らかの処理
    var delay = Math.random() * 2000;
    setTimeout(function(){
        resolve(delay + "ms");
    }, delay);
});
timeoutPromise(taskPromise, 1000).then(function(value){
    console.log("taskPromiseが時間内に終わった : " + value);
}).catch(function(error){
    console.log("タイムアウトになってしまった", error);
});</programlisting>
<simpara>タイムアウトになった場合はエラーが呼ばれるように出来ましたが、
このままでは<emphasis>通常のエラー</emphasis>と<emphasis>タイムアウトのエラー</emphasis>の区別がつかなくなってしまいます。</simpara>
<simpara>この <literal>Error</literal> オブジェクトの区別をしやすくするため、
<literal>Error</literal> オブジェクトのサブクラスとして <literal>TimeoutError</literal> を定義したいと思います。</simpara>
</section>
<section xml:id="_カスタムerrorオブジェクト">
<title>カスタムErrorオブジェクト</title>
<simpara><literal>Error</literal> オブジェクトはECMAScriptのビルトインオブジェクトです。</simpara>
<simpara>ECMAScript5では完璧に <literal>Error</literal> を継承したものを作る事は不可能ですが(スタックトレース周り等)、
今回は通常のErrorとは区別を付けたいという目的なので、それを満たせる <literal>TimeoutError</literal> オブジェクトを作成します。</simpara>
<note>
<simpara>ECMAScript 6では <literal>class</literal> 構文を使うことで内部的にも正確に継承を行うことが出来ます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">class MyError extends Error{
    // Errorを継承したオブジェクト
}</programlisting>
</note>
<simpara><literal>error instanceof TimeoutError</literal> というように利用できる <literal>TimeoutError</literal> を定義すると
以下のようになります。</simpara>
<formalpara xml:id="TimeoutError.js">
<title>TimeoutError.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function copyOwnFrom(target, source) {
    Object.getOwnPropertyNames(source).forEach(function (propName) {
        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));
    });
    return target;
}
function TimeoutError() {
    var superInstance = Error.apply(null, arguments);
    copyOwnFrom(this, superInstance);
}
TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.constructor = TimeoutError;</programlisting>
</para>
</formalpara>
<simpara><literal>TimeoutError</literal> というコンストラクタ関数を定義して、このコンストラクタにErrorをprototype継承させています。</simpara>
<simpara>使い方は通常の <literal>Error</literal> オブジェクトと同じで以下のように <literal>throw</literal> するなどして利用できます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var promise = new Promise(function(){
    throw new TimeoutError("timeout");
});

promise.catch(function(error){
    console.log(error instanceof TimeoutError);// true
});</programlisting>
<simpara>この <literal>TimeoutError</literal> を使えば、タイムアウトによるErrorオブジェクトなのか、他の原因のErrorオブジェクトなのかが容易に判定できるようになります。</simpara>
<note>
<simpara>今回紹介したビルトインオブジェクトを継承したオブジェクトの作成方法については
<link xl:href="http://speakingjs.com/es5/ch28.html">Chapter 28. Subclassing Built-ins</link> で詳しく紹介されています。
また、 <link xl:href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">Error - JavaScript | MDN</link> にもErrorオブジェクトについて書かれています。</simpara>
</note>
</section>
<section xml:id="_タイムアウトによるxhrのキャンセル">
<title>タイムアウトによるXHRのキャンセル</title>
<simpara>ここまでくれば、どのようにPromiseを使ったXHRのキャンセルを実装するか見えてくるかもしれません。</simpara>
<simpara>XHRのキャンセル自体は <literal>XMLHttpRequest</literal> オブジェクトの <literal>abort()</literal> メソッドを呼ぶだけなので難しくないですね。</simpara>
<simpara><literal>abort()</literal> メソッドを外から呼べるようにするために、今までのセクションにもでてきた<link linkend="xhr-promise.js"><literal>getURL</literal></link>を少し拡張して、
XHRを包んだpromiseオブジェクトと共にそのXHRを中止するメソッドを持つオブジェクトを返すようにしています。</simpara>
<formalpara xml:id="delay-race-cancel.js">
<title>delay-race-cancel.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function cancelableXHR(URL) {
    var req = new XMLHttpRequest();
    var promise = new Promise(function (resolve, reject) {
            req.open('GET', URL, true);
            req.onload = function () {
                if (req.status === 200) {
                    resolve(req.responseText);
                } else {
                    reject(new Error(req.statusText));
                }
            };
            req.onerror = function () {
                reject(new Error(req.statusText));
            };
            req.onabort = function () {
                reject(new Error('abort this request'));
            };
            req.send();
        });
    var abort = function () {
        // 既にrequestが止まってなければabortする
        // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
        if (req.readyState !== XMLHttpRequest.UNSENT) {
            req.abort();
        }
    };
    return {
        promise: promise,
        abort: abort
    };
}</programlisting>
</para>
</formalpara>
<simpara>これで必要な要素は揃ったので後は、Promiseを使った処理のフローに並べていくだけです。
大まかな流れとしては以下のようになります。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>cancelableXHR</literal> を使いXHRのpromiseオブジェクトと中止を呼び出すメソッドを取得する</simpara>
</listitem>
<listitem>
<simpara><literal>timeoutPromise</literal> を使いXHRのpromiseとタイムアウト用のpromiseを <literal>Promise.race</literal> で競争させる</simpara>
<itemizedlist>
<listitem>
<simpara>XHRが時間内に取得出来た場合</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>通常のpromiseと同様に <literal>then</literal> で中身を取得する</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>タイムアウトとなった場合は</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>throw new TimeoutError</literal> されるので <literal>catch</literal> する</simpara>
</listitem>
<listitem>
<simpara>catchしたエラーオブジェクトが <literal>TimeoutError</literal> のものだったら <literal>abort</literal> を呼び出してXHRをキャンセルする</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>これらの要素を全てまとめると次のように書けます。</simpara>
<formalpara xml:id="delay-race-cancel-play.js" role="executable">
<title>delay-race-cancel-play.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function copyOwnFrom(target, source) {
    Object.getOwnPropertyNames(source).forEach(function (propName) {
        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));
    });
    return target;
}
function TimeoutError() {
    var superInstance = Error.apply(null, arguments);
    copyOwnFrom(this, superInstance);
}
TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.constructor = TimeoutError;
function delayPromise(ms) {
    return new Promise(function (resolve) {
        setTimeout(resolve, ms);
    });
}
function timeoutPromise(promise, ms) {
    var timeout = delayPromise(ms).then(function () {
            return Promise.reject(new TimeoutError('Operation timed out after ' + ms + ' ms'));
        });
    return Promise.race([promise, timeout]);
}
function cancelableXHR(URL) {
    var req = new XMLHttpRequest();
    var promise = new Promise(function (resolve, reject) {
            req.open('GET', URL, true);
            req.onload = function () {
                if (req.status === 200) {
                    resolve(req.responseText);
                } else {
                    reject(new Error(req.statusText));
                }
            };
            req.onerror = function () {
                reject(new Error(req.statusText));
            };
            req.onabort = function () {
                reject(new Error('abort this request'));
            };
            req.send();
        });
    var abort = function () {
        // 既にrequestが止まってなければabortする
        // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
        if (req.readyState !== XMLHttpRequest.UNSENT) {
            req.abort();
        }
    };
    return {
        promise: promise,
        abort: abort
    };
}
var object = cancelableXHR('http://httpbin.org/get');
// main
timeoutPromise(object.promise, 1000).then(function (contents) {
    console.log('Contents', contents);
}).catch(function (error) {
    if (error instanceof TimeoutError) {
        object.abort();
        console.log(error);
        return;
    }
    console.log('XHR Error :', error);
});</programlisting>
</para>
</formalpara>
<simpara>これで、一定時間後に解決されるpromiseオブジェクトを使ったタイムアウト処理が実現できました。</simpara>
<note>
<simpara>通常の開発の場合は繰り返し使えるように、それぞれファイルに分割して定義しておくといいですね。</simpara>
</note>
</section>
<section xml:id="_promiseと操作メソッド">
<title>promiseと操作メソッド</title>
<simpara>先ほどの<link linkend="delay-race-cancel.js"><literal>cancelableXHR</literal></link>はpromiseオブジェクトと操作のメソッドが
一緒になったオブジェクトを返すようにしていたため少し分かりにくかったかもしれません。</simpara>
<simpara>一つの関数は一つの値(promiseオブジェクト)を返すほうが見通しがいいと思いますが、
<literal>cancelableXHR</literal> の中で生成した <literal>req</literal> は外から参照できないので、特定のメソッド(先ほどのケースは <literal>abort</literal>)からは触れるようにする必要があります。</simpara>
<simpara>返すpromiseオブジェクト自体を拡張して <literal>abort</literal> 出来るようにするという手段もあると思いますが、
promiseオブジェクトは値を抽象化したオブジェクトであるため、何でも操作用のメソッドをつけていくと複雑になってしまうかもしれません。</simpara>
<simpara>一つの関数で全てやろうとしてるのがそもそも良くないので、
ひとつの関数で何でもやるのは止めて、以下のように関数に分離していくというのが妥当な気がします。</simpara>
<itemizedlist>
<listitem>
<simpara>XHRを行うpromiseオブジェクトを返す</simpara>
</listitem>
<listitem>
<simpara>promiseオブジェクトを渡したら該当するXHRを止める</simpara>
</listitem>
</itemizedlist>
<simpara>これらの処理をまとめたモジュールを作れば今後の拡張がしやすいですし、
一つの関数がやることも小さくて済むので見通しも良くなると思います。</simpara>
<simpara>モジュールの作り方は色々作法(AMD,CommonJS,ES6 module etc..)があるので
ここでは、先ほどの <literal>cancelableXHR</literal> をNode.jsのモジュールとして作りなおしてみます。</simpara>
<formalpara xml:id="cancelableXHR.js">
<title>cancelableXHR.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">"use strict";
var requestMap = {};
function createXHRPromise(URL) {
    var req = new XMLHttpRequest();
    var promise = new Promise(function (resolve, reject) {
        req.open('GET', URL, true);
        req.onreadystatechange = function () {
            if (req.readyState === XMLHttpRequest.DONE) {
                delete requestMap[URL];
            }
        };
        req.onload = function () {
            if (req.status === 200) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = function () {
            reject(new Error(req.statusText));
        };
        req.onabort = function () {
            reject(new Error('abort this req'));
        };
        req.send();
    });
    requestMap[URL] = {
        promise: promise,
        request: req
    };
    return promise;
}

function abortPromise(promise) {
    if (typeof promise === "undefined") {
        return;
    }
    var request;
    Object.keys(requestMap).some(function (URL) {
        if (requestMap[URL].promise === promise) {
            request = requestMap[URL].request;
            return true;
        }
    });
    if (request != null &amp;&amp; request.readyState !== XMLHttpRequest.UNSENT) {
        request.abort();
    }
}
module.exports.createXHRPromise = createXHRPromise;
module.exports.abortPromise = abortPromise;</programlisting>
</para>
</formalpara>
<simpara>使い方もシンプルに <literal>createXHRPromise</literal> でXHRのpromiseオブジェクトを作成して、
そのXHRを <literal>abort</literal> したい場合は <literal>abortPromise(promise)</literal> にpromiseオブジェクトを渡すという感じで利用できるようになります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var cancelableXHR = require("./cancelableXHR");

var xhrPromise = cancelableXHR.createXHRPromise('http://httpbin.org/get');<co xml:id="CO14-1"/>
xhrPromise.catch(function (error) {
    // abort されたエラーが呼ばれる
});
cancelableXHR.abortPromise(xhrPromise);<co xml:id="CO14-2"/></programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>XHRをラップしたpromiseオブジェクトを作成</para>
</callout>
<callout arearefs="CO14-2">
<para>1で作成したpromiseオブジェクトのリクエストをキャンセル</para>
</callout>
</calloutlist>
</section>
<section xml:id="_まとめ_8">
<title>まとめ</title>
<simpara>ここでは以下の事について学びました。</simpara>
<itemizedlist>
<listitem>
<simpara>一定時間後に解決されるdelayPromise</simpara>
</listitem>
<listitem>
<simpara>delayPromiseとPromise.raceを使ったタイムアウトの実装</simpara>
</listitem>
<listitem>
<simpara>XHRのpromiseのリクエストのキャンセル</simpara>
</listitem>
<listitem>
<simpara>モジュール化によるpromiseオブジェクトと操作の分離</simpara>
</listitem>
</itemizedlist>
<simpara>Promiseは処理のフローを制御する力に優れているため、
それを最大限活かすためには一つの関数でやり過ぎないで処理を小さく分けること等、
今までのJavaScriptで言われているような事をより意識していいのかもしれません。</simpara>
</section>
</section>
<section xml:id="promise-done">
<title>Promise.prototype.done とは何か?</title>
<simpara>既存のPromise実装ライブラリを利用したことがある人は、
<literal>then</literal> の代わりに使う <literal>done</literal> というメソッドを見たことがあるかもしれません。</simpara>
<simpara>それらのライブラリでは <literal>Promise.prototype.done</literal> というような実装が存在し、
使い方は <literal>then</literal> と同じですが、promiseオブジェクトを返さないようになっています。</simpara>
<simpara><literal>Promise.prototype.done</literal> は、<link linkend="es6-promises">ES6 Promises</link>や<link linkend="promises-aplus">Promises/A+</link>の仕様には
存在していない記述ですが、多くのライブラリが実装しています。</simpara>
<simpara>このセクションでは、<literal>Promise.prototype.done</literal> とは何か?
また何故このようなメソッドが多くのライブラリで実装されているかについて学んでいきましょう。</simpara>
<section xml:id="_doneを使ったコード例">
<title>doneを使ったコード例</title>
<simpara>実際にdoneを使ったコードを見てみると <literal>done</literal> の挙動が分かりやすいと思います。</simpara>
<formalpara xml:id="promise-done-example.js" role="executable">
<title>promise-done-example.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">if (typeof Promise.prototype.done === 'undefined') {
    Promise.prototype.done = function (onFulfilled, onRejected) {
        this.then(onFulfilled, onRejected).catch(function (error) {
            setTimeout(function () {
                throw error;
            }, 0);
        });
    };
}
var promise = Promise.resolve();
promise.done(function () {
    JSON.parse('this is not json');    // =&gt; SyntaxError: JSON.parse
});
// =&gt; ブラウザの開発ツールのコンソールを開いてみましょう</programlisting>
</para>
</formalpara>
<simpara>最初に述べたように、<literal>Promise.prototype.done</literal> は仕様としては存在しないため、
利用する際は実装されているライブラリを使うか自分で実装する必要があります。</simpara>
<simpara>実装については後で解説しますが、まずは <literal>then</literal> を使った場合と <literal>done</literal> を使ったものを比較してみます。</simpara>
<formalpara role="executable">
<title>thenを使った場合</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var promise = Promise.resolve();
promise.then(function () {
    JSON.parse("this is not json");
}).catch(function (error) {
    console.error(error);// =&gt; "SyntaxError: JSON.parse"
});</programlisting>
</para>
</formalpara>
<simpara>比べて見ると以下のような違いがあることが分かります。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>done</literal> はpromiseオブジェクトを返さない</simpara>
<itemizedlist>
<listitem>
<simpara>つまり、doneの後に <literal>catch</literal> 等のメソッドチェーンはできない</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>done</literal> の中で発生したエラーはそのまま外に例外として投げられる</simpara>
<itemizedlist>
<listitem>
<simpara>つまり、Promiseによるエラーハンドリングが行われない</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara><literal>done</literal> はpromiseオブジェクトを返していないので、
Promise chainの最後におくメソッドというのはわかると思います。</simpara>
<simpara>また、Promiseには強力なエラーハンドリング機能があると紹介していましたが、
<literal>done</literal> の中ではそのエラーハンドリングをワザと突き抜けて例外を出すようになっています。</simpara>
<simpara>何故このようなPromiseの機能とは相反するメソッドが、多くのライブラリで実装されているかについては
次のようなPromiseの失敗例を見ていくと分かるかもしれません。</simpara>
</section>
<section xml:id="_沈黙したエラー">
<title>沈黙したエラー</title>
<simpara>Promiseには強力なエラーハンドリング機能がありますが、
(デバッグツールが上手く働かない場合に)
この機能がヒューマンエラーをより複雑なものにしてしまう一面があります。</simpara>
<simpara>これは、<link linkend="then-or-catch">then or catch?</link>でも同様の内容が出てきたことを覚えているかもしれません。</simpara>
<simpara>次のような、promiseオブジェクトを返す関数を考えてみましょう。</simpara>
<formalpara xml:id="json-promise.js">
<title>json-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function JSONPromise(value) {
    return new Promise(function (resolve) {
        resolve(JSON.parse(value));
    });
}</programlisting>
</para>
</formalpara>
<simpara>渡された値を <literal>JSON.parse</literal> してpromiseオブジェクトを返す関数ですね。</simpara>
<simpara>以下のように使うことができ、<literal>JSON.parse</literal> はパースに失敗すると例外を投げるので、
それを <literal>catch</literal> することが出来ます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function JSONPromise(value) {
    return new Promise(function (resolve) {
        resolve(JSON.parse(value));
    });
}
// 実行例
var string = "jsonではない文字列";
JSONPromise(string).then(function (object) {
    console.log(object);
}).catch(function(error){
    // =&gt; JSON.parseで例外が発生した時
    console.error(error);
});</programlisting>
<simpara>ちゃんと <literal>catch</literal> していれば何も問題がないのですが、その処理を忘れてしまうというミスを
した時にどこでエラーが発生してるのかわからなくなるというヒューマンエラーを助長させる面があります。</simpara>
<formalpara>
<title>catchによるエラーハンドリングを忘れてしまった場合</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var string = "jsonではない文字列";
JSONPromise(string).then(function (object) {
    console.log(object);
}); <co xml:id="CO15-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO15-1">
<para>例外が投げられても何も処理されない</para>
</callout>
</calloutlist>
<simpara><literal>JSON.parse</literal> のような分かりやすい例の場合はまだ良いですが、
メソッドをtypoしたことによるSyntax Errorなどはより深刻な問題となりやすいです。</simpara>
<formalpara>
<title>typoによるエラー</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var string = "{}";
JSONPromise(string).then(function (object) {
    conosle.log(object);<co xml:id="CO16-1"/>
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO16-1">
<para>conosle というtypoがある</para>
</callout>
</calloutlist>
<simpara>この場合は、<literal>console</literal> を <literal>conosle</literal> とtypoしているため、以下のようなエラーが発生するはずです。</simpara>
<blockquote>
<simpara>ReferenceError: conosle is not defined</simpara>
</blockquote>
<simpara>しかし、Promiseではtry-catchされるため、エラーが握りつぶされてしまうという現象が起きてしまいます。
毎回、正しく <literal>catch</literal> の処理を書くことが出来る場合は何も問題ありませんが、
Promiseの実装によってはこのようなミスが検知しにくくなるケースがあることを知っておくべきでしょう。</simpara>
<simpara>このようなエラーの握りつぶしは<emphasis>unhandled rejection</emphasis>と言われることがあります。
"Rejectedされた時の処理がない"というそのままの意味ですね。</simpara>
<note>
<simpara>このunhandled rejectionが検知しにくい問題はPromiseの実装に依存します。
例えば、 <link xl:href="https://github.com/yahoo/ypromise">ypromise</link> はunhandled rejectionがある場合は、その事をコンソールに表示します。</simpara>
<blockquote>
<simpara>Promise rejected but no error handlers were registered to it</simpara>
</blockquote>
<simpara>また、 <link xl:href="https://github.com/petkaantonov/bluebird">Bluebird</link> の場合も、
明らかに人間のミスにみえるReferenceErrorの場合などはそのままコンソールにエラーを表示してくれます。</simpara>
<blockquote>
<simpara>"Possibly unhandled ReferenceError. conosle is not defined</simpara>
</blockquote>
<simpara>ネイティブのPromiseの場合も同様にこの問題への対処としてGC-based unhandled rejection trackingというものが
搭載されつつあります。</simpara>
<simpara>これはpromiseオブジェクトがガーベッジコレクションによって回収されるときに、
それがunhandled rejectionであるなら、エラー表示をするという仕組みがベースとなっているようです。</simpara>
<simpara><link xl:href="https://twitter.com/domenic/status/461154989856264192">Firefox</link> や <link xl:href="https://code.google.com/p/v8/issues/detail?id=3093">Chrome</link> のネイティブPromiseでは一部実装されています。</simpara>
</note>
</section>
<section xml:id="_doneの実装">
<title>doneの実装</title>
<simpara>Promiseにおける <literal>done</literal> は先程のエラーの握りつぶしを避けるにはどうするかという方法論として、
そもそもエラーハンドリングをしなければいい という豪快な解決方法を提供するメソッドです。</simpara>
<simpara><literal>done</literal> はPromiseの上に実装することが出来るので、
<literal>Promise.prototype.done</literal> というPromiseのprototype拡張として実装してみましょう。</simpara>
<formalpara xml:id="promise-prototype-done.js">
<title>promise-prototype-done.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">"use strict";
if (typeof Promise.prototype.done === "undefined") {
    Promise.prototype.done = function (onFulfilled, onRejected) {
        this.then(onFulfilled, onRejected).catch(function (error) {
            setTimeout(function () {
                throw error;
            }, 0);
        });
    };
}</programlisting>
</para>
</formalpara>
<simpara>どのようにPromiseの外へ例外を投げているかというと、
setTimeoutの中でthrowをすることで、外へそのまま例外を投げられることを利用しています。</simpara>
<formalpara>
<title>setTimeoutのコールバック内での例外</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">try{
    setTimeout(function callback() {
        throw new Error("error");<co xml:id="CO17-1"/>
    }, 0);
}catch(error){
    console.error(error);
}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO17-1">
<para>この例外はキャッチされない</para>
</callout>
</calloutlist>
<note>
<simpara>なぜ非同期の <literal>callback</literal> 内での例外をキャッチ出来ないのかは以下が参考になります。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://techblog.yahoo.co.jp/programming/javascript_error/">JavaScriptと非同期のエラー処理 - Yahoo! JAPAN Tech Blog</link></simpara>
</listitem>
</itemizedlist>
</note>
<simpara><link linkend="promise-prototype-done.js"><literal>Promise.prototype.done</literal></link> をよく見てみると、何も <literal>return</literal> していないこともわかると思います。
つまり、<literal>done</literal> は「ここでPromise chainは終了して、例外が起きた場合はそのままpromiseの外へ投げ直す」という処理になっています。</simpara>
<simpara>実装や環境がしっかり対応していれば、<emphasis>unhandled rejection</emphasis>の検知はできるため、必ずしも <literal>done</literal> が必要というわけではなく、
また今回の<link linkend="promise-prototype-done.js"><literal>Promise.prototype.done</literal></link>のように、<literal>done</literal> は既存のPromiseの上に実装することができるため、
<link linkend="es6-promises">ES6 Promises</link>の仕様そのものには入らなかったと言えるかもしれません。</simpara>
<note>
<simpara>今回の <literal>Promise.prototype.done</literal> の実装は <link xl:href="https://www.promisejs.org/">promisejs.org</link> を参考にしています。</simpara>
</note>
</section>
<section xml:id="_まとめ_9">
<title>まとめ</title>
<simpara>このセクションでは、 <link xl:href="https://github.com/kriskowal/q/wiki/API-Reference#promisedoneonfulfilled-onrejected-onprogress">Q</link> や <link xl:href="https://github.com/petkaantonov/bluebird">Bluebird</link> や <link xl:href="https://github.com/cscott/prfun#promisedone&#8212;&#8203;undefined">prfun</link> 等
多くのPromiseライブラリで実装されている <literal>done</literal> の基礎的な実装と、<literal>then</literal> とはどのような違いがあるかについて学びました。</simpara>
<simpara><literal>done</literal> には2つの側面があることがわかりました。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>done</literal> の中で起きたエラーは外へ例外として投げ直す</simpara>
</listitem>
<listitem>
<simpara>Promise chain を終了するという宣言</simpara>
</listitem>
</itemizedlist>
<simpara><link linkend="then-or-catch">then or catch?</link> と同様にPromiseにより沈黙してしまったエラーについては、
デバッグツールやライブラリの改善等で殆どのケースでは問題ではなくなるかもしれません。</simpara>
<simpara>また、<literal>done</literal> は値を返さない事でそれ以上Promise chainを繋げる事ができなくなるため、
そのような統一感を持たせるという用途で <literal>done</literal> を使うことも出来ます。</simpara>
<simpara><link linkend="es6-promises">ES6 Promises</link> では根本に用意されてる機能はあまり多くありません。
そのため、自ら拡張したり、拡張したライブラリ等を利用するケースが多いと思います。</simpara>
<simpara>その時でも何でもやり過ぎると、せっかく非同期処理をPromiseでまとめても複雑化してしまう場合があるため、
統一感を持たせるというのは抽象的なオブジェクトであるPromiseにおいては大事な部分と言えるかもしれません。</simpara>
<note>
<simpara><link xl:href="http://blog.getify.com/promises-part-4/">Promises: The Extension Problem (part 4) | getiblog</link> では、
Promiseの拡張を書く手法について書かれています。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Promise.prototype</literal> を拡張する方法</simpara>
</listitem>
<listitem>
<simpara>Wrapper/Delegate を使った抽象レイヤーを作る方法</simpara>
</listitem>
</itemizedlist>
<simpara>また、Delegateを利用した方法については、 <link xl:href="http://speakingjs.com/es5/ch28.html">Chapter 28. Subclassing Built-ins</link> にて
詳しく解説されています。</simpara>
</note>
</section>
</section>
<section xml:id="promise-and-method-chain">
<title>Promiseとメソッドチェーン</title>
<simpara>Promiseは <literal>then</literal> や <literal>catch</literal> 等のメソッドを繋げて書いていきます。
これはDOMやjQuery等でよくみられるメソッドチェーンとよく似ています。</simpara>
<simpara>一般的なメソッドチェーンは <literal>this</literal> を返すことで、メソッドを繋げて書けるようになっています。</simpara>
<note>
<simpara>メソッドチェーンの作り方については <link xl:href="http://taiju.hatenablog.com/entry/20100307/1267962826">メソッドチェーンの作り方 - あと味</link> などを参照するといいでしょう。</simpara>
</note>
<simpara>一方、Promiseは<link linkend="then-return-new-promise">毎回新しいpromiseオブジェクトを返す</link>ようになっていますが、
一般的なメソッドチェーンと見た目は全く同じです。</simpara>
<simpara>このセクションでは、一般的なメソッドチェーンで書かれたものを
インターフェースはそのままで内部的にはPromiseで処理されるようにする方法について学んでいきたいと思います。</simpara>
<section xml:id="_fsのメソッドチェーン">
<title>fsのメソッドチェーン</title>
<simpara>以下のような <link xl:href="http://nodejs.org/api/fs.html">Node.jsのfs</link>モジュールを例にしてみたいと思います。</simpara>
<simpara>また、今回の例は見た目のわかりやすさを重視しているため、
現実的にはあまり有用なケースとは言えないかもしれません。</simpara>
<formalpara xml:id="fs-method-chain.js">
<title>fs-method-chain.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">"use strict";
var fs = require("fs");
function File() {
    this.lastValue = null;
}
// Static method for File.prototype.read
File.read = function FileRead(filePath) {
    var file = new File();
    return file.read(filePath);
};
File.prototype.read = function (filePath) {
    this.lastValue = fs.readFileSync(filePath, "utf-8");
    return this;
};
File.prototype.transform = function (fn) {
    this.lastValue = fn.call(this, this.lastValue);
    return this;
};
File.prototype.write = function (filePath) {
    this.lastValue = fs.writeFileSync(filePath, this.lastValue);
    return this;
};
module.exports = File;</programlisting>
</para>
</formalpara>
<simpara>このモジュールは以下のようにread &#8594; transform &#8594; writeという流れを
メソッドチェーンで表現することができます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var File = require("./fs-method-chain");
var inputFilePath = "input.txt",
    outputFilePath = "output.txt";
File.read(inputFilePath)
    .transform(function (content) {
        return "&gt;&gt;" + content;
    })
    .write(outputFilePath);</programlisting>
<simpara><literal>transform</literal> は引数で受け取った値を変更する関数を渡して処理するメソッドです。
この場合は、readで読み込んだ内容の先頭に <literal>&gt;&gt;</literal> という文字列を追加しているだけです。</simpara>
</section>
<section xml:id="_promiseによるfsのメソッドチェーン">
<title>Promiseによるfsのメソッドチェーン</title>
<simpara>次に先ほどの<link linkend="fs-method-chain.js">メソッドチェーン</link>をインターフェースはそのまま維持して
内部的にPromiseを使った処理にしてみたいと思います。</simpara>
<formalpara xml:id="fs-promise-chain.js">
<title>fs-promise-chain.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">"use strict";
var fs = require("fs");
function File() {
    this.promise = Promise.resolve();
}
// Static method for File.prototype.read
File.read = function (filePath) {
    var file = new File();
    return file.read(filePath);
};

File.prototype.then = function (onFulfilled, onRejected) {
    this.promise = this.promise.then(onFulfilled, onRejected);
    return this;
};
File.prototype["catch"] = function (onRejected) {
    this.promise = this.promise.catch(onRejected);
    return this;
};
File.prototype.read = function (filePath) {
    return this.then(function () {
        return fs.readFileSync(filePath, "utf-8");
    });
};
File.prototype.transform = function (fn) {
    return this.then(fn);
};
File.prototype.write = function (filePath) {
    return this.then(function (data) {
        return fs.writeFileSync(filePath, data)
    });
};
module.exports = File;</programlisting>
</para>
</formalpara>
<simpara>内部に持ってるpromiseオブジェクトに対するエイリアスとして
<literal>then</literal> と <literal>catch</literal> を持たせていますが、それ以外のインターフェースは全く同じ使い方となっています。</simpara>
<simpara>そのため、先ほどのコードで <literal>require</literal> するモジュールを変更しただけで動作します。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var File = require("./fs-promise-chain");
var inputFilePath = "input.txt",
    outputFilePath = "output.txt";
File.read(inputFilePath)
    .transform(function (content) {
        return "&gt;&gt;" + content;
    })
    .write(outputFilePath);</programlisting>
<simpara><literal>File.prototype.then</literal> というメソッドは、
<literal>this.promise.then</literal> が返す新しいpromiseオブジェクトを <literal>this.promise</literal> に対して代入しています。</simpara>
<simpara>これはどういうことなのかというと、以下のように擬似的に展開してみると分かりやすいでしょう。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var File = require("./fs-promise-chain");
File.read(inputFilePath)
    .transform(function (content) {
        return "&gt;&gt;" + content;
    })
    .write(outputFilePath);
// =&gt; 擬似的に以下のような流れに展開できる
promise.then(function read(){
        return fs.readFileSync(filePath, "utf-8");
    }).then(function transform(content) {
         return "&gt;&gt;" + content;
    }).then(function write(){
        return fs.writeFileSync(filePath, data);
    });</programlisting>
<simpara><literal>promise = promise.then(&#8230;&#8203;)</literal> という書き方は一見すると、上書きしているようにみえるため、
それまでのpromiseのchainが途切れてしまうと思うかもしれません。</simpara>
<simpara>イメージとしては <literal>promise = addPromiseChain(promise, fn);</literal> のような感じになっていて、
既存のpromiseオブジェクトに対して新たな処理を<emphasis role="strong">追加</emphasis>したpromiseオブジェクトを作って返すため、
自分で逐次的に処理する機構を実装しなくても問題ないわけです。</simpara>
</section>
<section xml:id="_両者の違い">
<title>両者の違い</title>
<section xml:id="_同期と非同期">
<title>同期と非同期</title>
<simpara><xref linkend="fs-method-chain.js"/>と<link linkend="fs-promise-chain.js">Promise版</link>の違いを見ていくと、
そもそも両者には同期的、非同期的という大きな違いがあります。</simpara>
<simpara><xref linkend="fs-method-chain.js"/> のようなメソッドチェーンでもキュー等の処理を実装すれば、
非同期的なほぼ同様のメソッドチェーンを実装出来ますが、複雑になるため今回は単純な同期的なメソッドチェーンにしました。</simpara>
<simpara>Promise版は<link linkend="promise-is-always-async">コラム: Promiseは常に非同期?</link>で紹介したように
常に非同期処理となるため、promiseを使ったメソッドチェーンも非同期となっています。</simpara>
</section>
<section xml:id="_エラーハンドリング">
<title>エラーハンドリング</title>
<simpara><xref linkend="fs-method-chain.js"/>にはエラーハンドリングの処理は入っていないですが、
同期処理であるため全体を <literal>try-catch</literal> で囲む事で行えます。</simpara>
<simpara><link linkend="fs-promise-chain.js">Promise版</link> では内部で利用するpromiseオブジェクトの
<literal>then</literal> と <literal>catch</literal> へのエイリアスを用意してあるため、通常のpromiseと同じように <literal>catch</literal> によってエラーハンドリングが行えます。</simpara>
<formalpara>
<title>fs-promise-chainでのエラーハンドリング</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var File = require("./fs-promise-chain");
File.read(inputFilePath)
    .transform(function (content) {
        return "&gt;&gt;" + content;
    })
    .write(outputFilePath)
    .catch(function(error){
        console.error(error);
    });</programlisting>
</para>
</formalpara>
<simpara><xref linkend="fs-method-chain.js"/>に非同期処理を加えたものを自力で実装する場合、
エラーハンドリングが大きな問題となるため、非同期処理にしたい時は
Promiseを使うと比較的簡単に実装できると言えるかもしれません。</simpara>
</section>
</section>
<section xml:id="_promise以外での非同期処理">
<title>Promise以外での非同期処理</title>
<simpara>このメソッドチェーンと非同期処理を見てNode.jsに慣れている方は <link xl:href="http://nodejs.org/api/stream.html">Stream</link> が思い浮かぶと思います。</simpara>
<simpara><link xl:href="http://nodejs.org/api/stream.html">Stream</link> を使うと、
<literal>this.lastValue</literal> のような値を保持する必要がなくなる事や大きなファイルの扱いが改善されます。
また、Promiseを使った例に比べるとより高速に処理できる可能性が高いと思います。</simpara>
<formalpara>
<title>streamによるread&#8594;transform&#8594;write</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">readableStream.pipe(transformStream).pipe(writableStream);</programlisting>
</para>
</formalpara>
<simpara>そのため、非同期処理には常にPromiseが最適という訳ではなく、
目的と状況にあった実装をしていくことを考えていくべきでしょう。</simpara>
<note>
<simpara>Node.jsのStreamはEventをベースにしている技術</simpara>
</note>
<simpara>Node.jsのStreamについて詳しくは以下を参照して下さい。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://jxck.hatenablog.com/entry/20111204/1322966453">Node.js の Stream API で「データの流れ」を扱う方法 - Block Rockin’ Codes</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.slideshare.net/shigeki_ohtsu/stream2-kihon">Stream2の基本</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.slideshare.net/shigeki_ohtsu/node-v012tng12">Node-v0.12の新機能について</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_promiseラッパー">
<title>Promiseラッパー</title>
<simpara>話を戻して<xref linkend="fs-method-chain.js"/>と<link linkend="fs-promise-chain.js">Promise版</link>の両者を比べると、
内部的にもかなり似ていて、同期版のものがそのまま非同期版でも使えるような気がします。</simpara>
<simpara>JavaScriptでは動的にメソッドを定義することもできるため、
自動的にPromise版を生成できないかということを考えると思います。
(もちろん静的に定義する方が扱いやすいですが)</simpara>
<simpara>そのような仕組みは<link linkend="es6-promises">ES6 Promises</link>にはありませんが、
著名なサードパーティのPromise実装である <link xl:href="https://github.com/petkaantonov/bluebird/">bluebird</link> などには
<link xl:href="https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification">Promisification</link> という機能が用意されています。</simpara>
<simpara>これを利用すると以下のように、その場でpromise版のメソッドを追加して利用できるようになります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var fs = Promise.promisifyAll(require("fs"));

fs.readFileAsync("myfile.js", "utf8").then(function(contents){
    console.log(contents);
}).catch(function(e){
    console.error(e.stack);
});</programlisting>
<section xml:id="_arrayのpromiseラッパー">
<title>ArrayのPromiseラッパー</title>
<simpara>先ほどの <link xl:href="https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification">Promisification</link> が何をやっているのか少しイメージしにくいので、
次のようなネイティブ <literal>Array</literal> のPromise版となるメソッドを動的に定義する例を考えてみましょう。</simpara>
<simpara>JavaScriptにはネイティブにもDOMやString等メソッドチェーンが行える機能が多くあります。
<literal>Array</literal> もその一つで、<literal>map</literal> や <literal>filter</literal> 等のメソッドは配列を返すため、メソッドチェーンが利用しやすい機能です</simpara>
<formalpara xml:id="array-promise-chain.js">
<title>array-promise-chain.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">"use strict";
function ArrayAsPromise(array) {
    this.array = array;
    this.promise = Promise.resolve();
}
ArrayAsPromise.prototype.then = function (onFulfilled, onRejected) {
    this.promise = this.promise.then(onFulfilled, onRejected);
    return this;
};
ArrayAsPromise.prototype["catch"] = function (onRejected) {
    this.promise = this.promise.catch(onRejected);
    return this;
};
Object.getOwnPropertyNames(Array.prototype).forEach(function (methodName) {
    // Don't overwrite
    if (typeof ArrayAsPromise[methodName] !== "undefined") {
        return;
    }
    var arrayMethod = Array.prototype[methodName];
    if (typeof  arrayMethod !== "function") {
        return;
    }
    ArrayAsPromise.prototype[methodName] = function () {
        var that = this;
        var args = arguments;
        this.promise = this.promise.then(function () {
            that.array = Array.prototype[methodName].apply(that.array, args);
            return that.array;
        });
        return this;
    };
});

module.exports = ArrayAsPromise;
module.exports.array = function newArrayAsPromise(array) {
    return new ArrayAsPromise(array);
};</programlisting>
</para>
</formalpara>
<simpara>ネイティブのArrayと <literal>ArrayAsPromise</literal> を使った場合の違いは
<link linkend="array-promise-chain.js">上記のコード</link>のテストを見てみるのが分かりやすいでしょう。</simpara>
<formalpara xml:id="array-promise-chain-test.js">
<title>array-promise-chain-test.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">"use strict";
var assert = require("power-assert");
var ArrayAsPromise = require("../src/promise-chain/array-promise-chain");
describe("array-promise-chain", function () {
    function isEven(value) {
        return value % 2 === 0;
    }

    function double(value) {
        return value * 2;
    }

    beforeEach(function () {
        this.array = [1, 2, 3, 4, 5];
    });
    describe("Native array", function () {
        it("can method chain", function () {
            var result = this.array.filter(isEven).map(double);
            assert.deepEqual(result, [4, 8]);
        });
    });
    describe("ArrayAsPromise", function () {
        it("can promise chain", function (done) {
            var array = new ArrayAsPromise(this.array);
            array.filter(isEven).map(double).then(function (value) {
                assert.deepEqual(value, [4, 8]);
            }).then(done, done);
        });
    });
});</programlisting>
</para>
</formalpara>
<simpara><literal>ArrayAsPromise</literal> でもArrayのメソッドを利用できているのが分かります。
先ほどと同じように、ネイティブのArrayは同期処理で、<literal>ArrayAsPromise</literal> は非同期処理という違いがあります。</simpara>
<simpara><literal>ArrayAsPromise</literal> の実装を見て気づくと思いますが、<literal>Array.prototype</literal> のメソッドを全て実装しています。
しかし、<literal>array.indexOf</literal> など <literal>Array.prototype</literal> には配列を返さないものもあるため、全てをメソッドチェーンにするのは不自然なケースがあると思います。</simpara>
<simpara>ここで大事なのが、同じ値を受けるインターフェースを持っているAPIはこのような手段でPromise版のAPIを自動的に作成できるという点です。
このようなAPIの規則性を意識してみるとまた違った使い方が見つかるかもしれません。</simpara>
<note>
<simpara>先ほどの <link xl:href="https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification">Promisification</link> は
Node.jsのCoreモジュールの非同期処理には <literal>function(error,result){}</literal> というように第一引数に <literal>error</literal> が来るというルールを利用して、
自動的にPromiseでラップしたメソッドを生成しています</simpara>
</note>
</section>
</section>
<section xml:id="_まとめ_10">
<title>まとめ</title>
<simpara>このセクションでは以下のことについて学びました。</simpara>
<itemizedlist>
<listitem>
<simpara>Promise版のメソッドチェーンの実装</simpara>
</listitem>
<listitem>
<simpara>Promiseが常に非同期の最善の手段ではない</simpara>
</listitem>
<listitem>
<simpara>Promisification</simpara>
</listitem>
<listitem>
<simpara>統一的なインターフェースの再利用</simpara>
</listitem>
</itemizedlist>
<simpara><link linkend="es6-promises">ES6 Promises</link>はCoreとなる機能しか用意されていません。
そのため、自分でPromiseを使った既存の機能のラッパー的な実装をする事があるかもしれません。</simpara>
<simpara>しかし、何度もコールバックを呼ぶEventのような処理がPromiseには不向きなように、
Promiseが常に最適な非同期処理という訳ではありません。</simpara>
<simpara>その機能にPromiseを使うのが最適なのかを考える事はこの書籍の目的でもあるため、
何でもPromiseにするというわけではなく、その目的にPromiseが合うのかどうかを考えてみるのもいいと思います。</simpara>
</section>
</section>
<section xml:id="promise-sequence">
<title>Promiseによる逐次処理</title>
<simpara>第2章の<link linkend="ch2-promise-all">Promise.all</link>では、
複数のpromiseオブジェクトをまとめて処理する方法について学びました。</simpara>
<simpara>しかし、<literal>Promise.all</literal> は全ての処理を並行に行うため、
Aの処理 が終わったら Bの処理 というような逐次的な処理を扱うことが出来ません。</simpara>
<simpara>また、同じ2章の<link linkend="ch2-promise-and-array">Promiseと配列</link>では、
効率的ではないですが、<link linkend="multiple-xhr.js">thenを連ねた書き方</link>でそのような逐次処理を行っていました。</simpara>
<simpara>このセクションでは、Promiseを使った逐次処理の書き方について学んで行きたいと思います。</simpara>
<section xml:id="_ループと逐次処理">
<title>ループと逐次処理</title>
<simpara><link linkend="multiple-xhr.js">thenを連ねた書き方</link>では以下のような書き方でしたね。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function getURL(URL) {
    return new Promise(function (resolve, reject) {
        var req = new XMLHttpRequest();
        req.open('GET', URL, true);
        req.onload = function () {
            if (req.status === 200) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = function () {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
var request = {
        comment: function getComment() {
            return getURL('http://azu.github.io/promises-book/json/comment.json').then(JSON.parse);
        },
        people: function getPeople() {
            return getURL('http://azu.github.io/promises-book/json/people.json').then(JSON.parse);
        }
    };
function main() {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }
    // [] は記録する初期値を部分適用している
    var pushValue = recordValue.bind(null, []);
    return request.comment().then(pushValue).then(request.people).then(pushValue);
}
// 実行例
main().then(function (value) {
    console.log(value);
}).catch(function(error){
    console.error(error);
});</programlisting>
<simpara>この書き方だと、<literal>request</literal> の数が増える分 <literal>then</literal> を書かないといけなくなってしまいます。</simpara>
<simpara>そこで、処理を配列にまとめて、forループで処理していければ、数が増えた場合も問題無いですね。
まずはforループを使って先ほどと同じ処理を書いてみたいと思います。</simpara>
<formalpara xml:id="promise-foreach-xhr.js" role="executable">
<title>promise-foreach-xhr.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function getURL(URL) {
    return new Promise(function (resolve, reject) {
        var req = new XMLHttpRequest();
        req.open('GET', URL, true);
        req.onload = function () {
            if (req.status === 200) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = function () {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
var request = {
        comment: function getComment() {
            return getURL('http://azu.github.io/promises-book/json/comment.json').then(JSON.parse);
        },
        people: function getPeople() {
            return getURL('http://azu.github.io/promises-book/json/people.json').then(JSON.parse);
        }
    };
function main() {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }
    // [] は記録する初期値を部分適用してる
    var pushValue = recordValue.bind(null, []);
    // promiseオブジェクトを返す関数の配列
    var tasks = [request.comment, request.people];
    var promise = Promise.resolve();
    // スタート地点
    for (var i = 0; i &lt; tasks.length; i++) {
        var task = tasks[i];
        promise = promise.then(task).then(pushValue);
    }
    return promise;
}
// 実行例
main().then(function (value) {
    console.log(value);
}).catch(function(error){
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>forループで書く場合、<link linkend="then-return-new-promise">コラム: thenは常に新しいpromiseオブジェクトを返す</link>や<link linkend="promise-and-method-chain">Promiseとメソッドチェーン</link>で学んだように、
<link linkend="promise.then">Promise#then</link> は新しいpromiseオブジェクトを返しています。</simpara>
<simpara>そのため、<literal>promise = promise.then(task).then(pushValue);</literal> というのは <literal>promise</literal> という変数に上書きするというよりは、
そのpromiseオブジェクトに処理を追加していくような処理になっています。</simpara>
<simpara>しかし、この書き方だと一時変数として <literal>promise</literal> が必要で、処理の内容的にもあまりスッキリしません。</simpara>
<simpara>このループの書き方は <literal>Array.prototype.reduce</literal> を使うともっとスマートに書くことが出来ます。</simpara>
</section>
<section xml:id="_promise_chainとreduce">
<title>Promise chainとreduce</title>
<simpara><literal>Array.prototype.reduce</literal> を使って書き直すと以下のようになります。</simpara>
<formalpara xml:id="promise-reduce-xhr.js" role="executable">
<title>promise-reduce-xhr.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function getURL(URL) {
    return new Promise(function (resolve, reject) {
        var req = new XMLHttpRequest();
        req.open('GET', URL, true);
        req.onload = function () {
            if (req.status === 200) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = function () {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
var request = {
        comment: function getComment() {
            return getURL('http://azu.github.io/promises-book/json/comment.json').then(JSON.parse);
        },
        people: function getPeople() {
            return getURL('http://azu.github.io/promises-book/json/people.json').then(JSON.parse);
        }
    };
function main() {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }
    var pushValue = recordValue.bind(null, []);
    var tasks = [request.comment, request.people];
    return tasks.reduce(function (promise, task) {
        return promise.then(task).then(pushValue);
    }, Promise.resolve());
}
// 実行例
main().then(function (value) {
    console.log(value);
}).catch(function(error){
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><literal>main</literal> 以外の処理はforループのものと同様です。</simpara>
<simpara><literal>Array.prototype.reduce</literal> は第二引数に初期値を入れることができます。
つまりこの場合、最初の <literal>promise</literal> には <literal>Promise.resolve()</literal> が入り、
そのときの <literal>task</literal> は <literal>request.comment</literal> となります。</simpara>
<simpara>reduceの中で <literal>return</literal> したものが、次のループで <literal>promise</literal> に入ります。
つまり、<literal>then</literal> を使って作成した新たなpromiseオブジェクトを返すことで、
forループの場合と同じように<link linkend="promise-chain">Promise chain</link>を繋げることが出来ます。</simpara>
<note>
<simpara><literal>Array.prototype.reduce</literal> については詳しくは以下を参照して下さい。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.prototype.reduce() - JavaScript | MDN</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://azu.github.io/slide/JSGohan/reduce.html">Array.prototype.reduce Dance</link></simpara>
</listitem>
</itemizedlist>
</note>
<simpara>forループと異なる点は、一時変数としての <literal>promise</literal> が不要になることに伴い、
<literal>promise = promise.then(task).then(pushValue);</literal> という不格好な書き方がなくなる点が大きな違いだと思います。</simpara>
<simpara><literal>Array.prototype.reduce</literal> とPromiseの逐次処理は相性が良いので覚えておくといいのですが、
初めて見た時にどういう動作をするのかがまだ分かりにくいという問題があります。</simpara>
<simpara>そこで、処理するTaskとなる関数の配列を受け取って逐次処理を行う
<literal>sequenceTasks</literal> というものを作ってみます。</simpara>
<simpara>以下のように書くことができれば、<literal>tasks</literal> が順番に処理されていく事が関数名から見てわかるようになります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var tasks = [request.comment, request.people];
sequenceTasks(tasks);</programlisting>
</section>
<section xml:id="_逐次処理を行う関数を定義する">
<title>逐次処理を行う関数を定義する</title>
<simpara>基本的には、<link linkend="promise-reduce-xhr.js">reduceを使ったやり方</link>を関数として切り離せばいいだけですね。</simpara>
<formalpara xml:id="promise-sequence.js">
<title>promise-sequence.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function sequenceTasks(tasks) {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }
    var pushValue = recordValue.bind(null, []);
    return tasks.reduce(function (promise, task) {
        return promise.then(task).then(pushValue);
    }, Promise.resolve());
}</programlisting>
</para>
</formalpara>
<simpara>一つ注意点として、<literal>Promise.all</literal> 等と違い、引数に受け取るのは関数の配列です。</simpara>
<simpara>何故、渡すのがpromiseオブジェクトの配列ではないのかというと、
promiseオブジェクトを作った段階で既にXHRが実行されている状態なので、
それを逐次処理しても意図とは異なる動作になるためです。</simpara>
<simpara>そのため <literal>sequenceTasks</literal> では関数(promiseオブジェクトを返す)の配列を引数に受け取ります。</simpara>
<simpara>最後に、<literal>sequenceTasks</literal> を使って最初の例を書き換えると以下のようになります。</simpara>
<formalpara xml:id="promise-sequence-xhr.js" role="executable">
<title>promise-sequence-xhr.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function sequenceTasks(tasks) {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }
    var pushValue = recordValue.bind(null, []);
    return tasks.reduce(function (promise, task) {
        return promise.then(task).then(pushValue);
    }, Promise.resolve());
}
function getURL(URL) {
    return new Promise(function (resolve, reject) {
        var req = new XMLHttpRequest();
        req.open('GET', URL, true);
        req.onload = function () {
            if (req.status === 200) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = function () {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
var request = {
        comment: function getComment() {
            return getURL('http://azu.github.io/promises-book/json/comment.json').then(JSON.parse);
        },
        people: function getPeople() {
            return getURL('http://azu.github.io/promises-book/json/people.json').then(JSON.parse);
        }
    };
function main() {
    return sequenceTasks([request.comment, request.people]);
}
// 実行例
main().then(function (value) {
    console.log(value);
}).catch(function(error){
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><literal>main()</literal> の中がかなりスッキリしたことが分かります。</simpara>
<simpara>このようにPromiseでは、逐次処理という事をするのに色々な書き方が出来ると思います。</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="multiple-xhr.js">thenをその場に並べた書き方</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="promise-foreach-xhr.js">forループを使った書き方</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="promise-reduce-xhr.js">reduceを使った書き方</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="promise-sequence.js">逐次処理する関数を分けた書き方</link></simpara>
</listitem>
</itemizedlist>
<simpara>しかし、これはJavaScriptで配列を扱うのにforループや <literal>forEach</literal> 等、色々やり方があるのと本質的には違いはありません。
そのため、Promiseを扱う場合も処理をまとめられるところは小さく関数に分けて、実装していくのがいいと言えるでしょう。</simpara>
</section>
<section xml:id="_まとめ_11">
<title>まとめ</title>
<simpara>このセクションでは、<link linkend="Promise.all"><literal>Promise.all</literal></link>とは違い、
一つづつ順番に処理したい場合に、Promiseでどのように実装していくかについて学びました。</simpara>
<simpara>手続き的な書き方から、逐次処理を行う関数を定義するところまで見ていき、
Promiseであっても関数に処理を分けるという基本的な事は変わらないことを示しました。</simpara>
<simpara>Promiseで書くとPromise chainを繋げすぎて縦に長い処理を書いてしまうことがあります。</simpara>
<simpara>そんな時は基本に振り返り、処理を関数に分けることで全体の見通しを良くすることは大切です。</simpara>
<simpara>また、Promiseのコンストラクタ関数や <literal>then</literal> 等は高階関数なので、
処理を関数に分けておくと組み合わせが行い易いという副次的な効果もあるため、意識してみるといいかもしれません。</simpara>
<note>
<simpara>高階関数とは引数に関数オブジェクトを受け取る関数のこと</simpara>
</note>
</section>
</section>
</section>
<section xml:id="promise-api-reference">
<title>Promises API Reference</title>
<section xml:id="promise.then">
<title>Promise#then</title>
<programlisting language="javascript" linenumbering="unnumbered">promise.then(onFulfilled, onRejected);</programlisting>
<formalpara role="executable">
<title>thenコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var promise = new Promise(function(resolve, reject){
    resolve("thenに渡す値");
});
promise.then(function (value) {
    console.log(value);
}, function (error) {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>promiseオブジェクトに対してonFulfilledとonRejectedのハンドラを定義し、
新たなpromiseオブジェクトを作成して返す。</simpara>
<simpara>このハンドラはpromiseがresolve または rejectされた時にそれぞれ呼ばれる。</simpara>
<itemizedlist>
<listitem>
<simpara>定義されたハンドラ内で返した値は、新たなpromiseオブジェクトのonFulfilledに対して渡される。</simpara>
</listitem>
<listitem>
<simpara>定義されたハンドラ内で例外が発生した場合は、新たなpromiseオブジェクトのonRejectedに対して渡される。</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="promise.catch">
<title>Promise#catch</title>
<programlisting language="javascript" linenumbering="unnumbered">promise.catch(onRejected);</programlisting>
<formalpara role="executable">
<title>catchのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var promise = new Promise(function(resolve, reject){
    resolve("thenに渡す値");
});
promise.then(function (value) {
    console.log(value);
}).catch(function (error) {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><literal>promise.then(undefined, onRejected)</literal> と同等の意味を持つシンタックスシュガー。</simpara>
</section>
<section xml:id="Promise.resolve">
<title>Promise.resolve</title>
<programlisting language="javascript" linenumbering="unnumbered">Promise.resolve(promise);
Promise.resolve(thenable);
Promise.resolve(object);</programlisting>
<formalpara role="executable">
<title>Promise.resolveのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var taskName = "task 1"
asyncTask(taskName).then(function (value) {
    console.log(value);
}).catch(function (error) {
    console.error(error);
});
function asyncTask(name){
    return Promise.resolve(name).then(function(value){
        return "Done! "+ value;
    });
}</programlisting>
</para>
</formalpara>
<simpara>受け取った値に応じたpromiseオブジェクトを返す。</simpara>
<simpara>どの場合でもpromiseオブジェクトを返すが、大きく分けて以下の3種類となる。</simpara>
<variablelist>
<varlistentry>
<term>promiseオブジェクトを受け取った場合</term>
<listitem>
<simpara>受け取ったpromiseオブジェクトをそのまま返す</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>thenableなオブジェクトを受け取った場合</term>
<listitem>
<simpara><literal>then</literal> を持つオブジェクトを新たなpromiseオブジェクトにして返す</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>その他の値(オブジェクトやnull等も含む)を受け取った場合</term>
<listitem>
<simpara>その値でresolveされる新たなpromiseオブジェクトを作り返す</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="Promise.reject">
<title>Promise.reject</title>
<programlisting language="javascript" linenumbering="unnumbered">Promise.reject(object)</programlisting>
<formalpara>
<title>Promise.rejectのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var failureStub = sinon.stub(xhr, "request").returns(Promise.reject(new Error("bad!")));</programlisting>
</para>
</formalpara>
<simpara>受け取った値でrejectされた新たなpromiseオブジェクトを返す。</simpara>
<simpara>Promise.rejectに渡す値は <literal>Error</literal> オブジェクトとすべきである。</simpara>
<simpara>また、Promise.resolveとは異なり、promiseオブジェクトを渡した場合も常に新たなpromiseオブジェクトを作成する。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">var r = Promise.reject(new Error("error"));
console.log(r === Promise.reject(r));// false</programlisting>
</section>
<section xml:id="Promise.all">
<title>Promise.all</title>
<programlisting language="javascript" linenumbering="unnumbered">Promise.all(promiseArray);</programlisting>
<formalpara role="executable">
<title>Promise.allのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var p1 = Promise.resolve(1),
    p2 = Promise.resolve(2),
    p3 = Promise.resolve(3);
Promise.all([p1, p2, p3]).then(function (results) {
    console.log(results);  // [1, 2, 3]
});</programlisting>
</para>
</formalpara>
<simpara>新たなpromiseオブジェクトを作成して返す。</simpara>
<simpara>渡されたpromiseオブジェクトの配列が全てresolveされた時に、
新たなpromiseオブジェクトはその値でresolveされる。</simpara>
<simpara>どれかの値がrejectされた場合は、その時点で新たなpromiseオブジェクトはrejectされる。</simpara>
<simpara>渡された配列の値はそれぞれ <literal>Promise.resolve</literal> にラップされるため、
promiseオブジェクト以外が混在している場合も扱える。</simpara>
</section>
<section xml:id="Promise.race">
<title>Promise.race</title>
<programlisting language="javascript" linenumbering="unnumbered">Promise.race(promiseArray);</programlisting>
<formalpara role="executable">
<title>Promise.raceのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">var p1 = Promise.resolve(1),
    p2 = Promise.resolve(2),
    p3 = Promise.resolve(3);
Promise.race([p1, p2, p3]).then(function (value) {
    console.log(value);  // 1
});</programlisting>
</para>
</formalpara>
<simpara>新たなpromiseオブジェクトを作成して返す。</simpara>
<simpara>渡されたpromiseオブジェクトの配列のうち、
一番最初にresolve または rejectされたpromiseにより、
新たなpromiseオブジェクトはその値でresolve または rejectされる。</simpara>
</section>
</section>
<section xml:id="promise-glossary">
<title>用語集</title>
<variablelist>
<varlistentry>
<term>Promises</term>
<listitem>
<simpara>プロミスという仕様そのもの</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>promiseオブジェクト</term>
<listitem>
<simpara>プロミスオブジェクト、<literal>Promise</literal> のインスタンスオブジェクトの事</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="es6-promises">
<varlistentry>
<term>ES6 Promises</term>
<listitem>
<simpara><link xl:href="http://www.ecma-international.org/ecma-262/6.0/index.html">ECMAScript 6th Edition(ECMAScript 2015)</link> を明示的に示す場合にprefixとして <emphasis>ES6</emphasis> をつける</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="promises-aplus">
<varlistentry>
<term>Promises/A+</term>
<listitem>
<simpara><link xl:href="http://promises-aplus.github.io/promises-spec/">Promises/A+</link>の事。
ES6 Promisesの前身となったコミュニティベースの仕様であり、ES6 Promisesとは多くの部分が共通している。</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="Thenable">
<varlistentry>
<term>Thenable</term>
<listitem>
<simpara>Promiseライクなオブジェクトの事。
<literal>.then</literal> というメソッドを持つオブジェクト。</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="promise-chain">
<varlistentry>
<term>promise chain</term>
<listitem>
<simpara>promiseオブジェクトを <literal>then</literal> や <literal>catch</literal> のメソッドチェーンでつなげたもの。
この用語は書籍中のものであり、<link linkend="es6-promises">ES6 Promises</link>で定められた用語ではありません。</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="resouce-link">
<title>参考サイト</title>
<variablelist>
<varlistentry>
<term><link xl:href="https://github.com/w3ctag/promises-guide">w3ctag/promises-guide</link> <link xl:href="http://www.hcn.zaq.ne.jp/___/WEB/promises-guide-ja.html">（日本語訳）</link></term>
<listitem>
<simpara>Promisesのガイド - 概念的な説明はここから得たものが多い</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="https://github.com/domenic/promises-unwrapping">domenic/promises-unwrapping</link></term>
<listitem>
<simpara>ES6 Promisesの仕様の元となったリポジトリ - issueを検索して得た経緯や情報も多い</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise-objects">ECMAScript 2015 Language Specification – ECMA-262 6th Edition</link></term>
<listitem>
<simpara>ES6 Promisesの仕様書 - 仕様書として参照する場合はこちらを優先した</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="http://www.html5rocks.com/ja/tutorials/es6/promises/">JavaScript Promises: There and back again - HTML5 Rocks</link></term>
<listitem>
<simpara>Promisesについての記事 - 完成度がとても高くサンプルコードやリファレンス等を参考にした</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="http://d.hatena.ne.jp/jovi0608/20140319/1395199285">Node.jsにPromiseが再びやって来た！ - ぼちぼち日記</link></term>
<listitem>
<simpara>Node.jsとPromiseの記事 - <emphasis>thenable</emphasis>について参考にした</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="http://exploringjs.com/">Exploring ES6: Upgrade to the next version of JavaScript</link></term>
<listitem>
<simpara>ECMAScript 6全般について詳しく書かれている書籍</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="about-author">
<title>著者について</title>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="Appendix-Glossary/img/simple320_320.png" contentwidth="32" contentdepth="32"/>
</imageobject>
<textobject><phrase>azu</phrase></textobject>
</inlinemediaobject>
<emphasis role="strong"><link xl:href="https://github.com/azu/">azu</link></emphasis> (Twitter : @<link xl:href="https://twitter.com/azu_re">azu_re</link> )</simpara>
<simpara>ブラウザ、JavaScriptの最新技術を常に追いかけている。</simpara>
<simpara>目的を手段にしてしまうことを得意としている(この書籍もその結果できた)。</simpara>
<simpara><link xl:href="http://efcl.info/">Web Scratch</link> や <link xl:href="http://jser.info/">JSer.info</link> といったサイトを運営している。</simpara>
<section xml:id="omake-message">
<title>著者へのメッセージ/おまけ</title>
<simpara>以下の <link xl:href="https://gumroad.com/l/javascript-promise">おまけ.pdf</link> では、
この書籍を書き始めた理由や、どのように書いていったか、テストなどについて書かれています。</simpara>
<itemizedlist>
<listitem>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="public/img/gumroad-green.svg"/>
</imageobject>
<textobject><phrase>おまけをダウンロード</phrase></textobject>
</inlinemediaobject> <link xl:href="https://gumroad.com/l/javascript-promise">JavaScript Promiseの本のおまけ</link></simpara>
</listitem>
</itemizedlist>
<simpara>Gumroadから無料 または 好きな値段でダウンロードすることが出来ます。</simpara>
<simpara>ダウンロードする際に作者へのメッセージも書けるので、
メッセージを残すついでにダウンロードして行ってください。</simpara>
<simpara>問題の指摘などがありましたら、GitHubやGitterに書いてくださると解決出来ます。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/azu/promises-book/issues?state=open">Issues · azu/promises-book</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://gitter.im/azu/promises-book">azu/promises-book - Gitter</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</article>